---
title: Stilizziamo i componenti
description: Lo stile dei componenti √® un'attivit√† essenziale ma molto complessa. In questa guida non voglio insegnarvi ad usare lo stile, ma presentarvi alcune tecniche molto utili per iniziare ad aggiungere stile ai nostri component.
published: false
slug: component-styling
---

Nei capitoli precedenti abbiamo iniziato a muoverci all'intenro del progetto NextJS e iniato a creare pagine e
componenti sfruttando la libreria ReactJS, su cui NextJS si basa.

Prima di iniziare a lavorare veramente su un progetto, ci manca un punto fondamentale: come stilizziamo i nostri componenti?

Purtroppo su questo tema entriamo in una giungla di soluzioni e tecnologie diverse, in quanto attualmente all'interno della
community ReactJS, non si √® trovata una tecnologia (o un gruppo di tecnologie) abbastanza orizzontale sui vari proggetti, invece
esistono diversi approcci (anche moldi diversi tra loro) e diverse preferenze tra gli sviluppatori.

Lo stile in HTML si basa sull'utilizzo della tecnologia CSS. L'idea di base di HTML e CSS √® quella di definire separatamente
il contenuto di un documento (HTML) dal modo in cui viene visualizzato (CSS). Sebbena questa idea in teoria sia molto valida,
nella pratica ci si rende subito conto che non √® tanto semplice da portare avanti. Anche in caso di organizzazione perfetta
del nostro HTML, ci troveremo comunque a doverne modificare l'organizzazione in base ad esigenze di stile e viceversa.

Per questo motivo, si √® visto che l'approccio standard di definire CSS e HTML in posti e file diversi tra loro semplicemente
non funziona, e in progetti grandi (ma anche medi) porta a codice difficile da mantenere e capirne il funzionamento?

Come fare quindi? In React esistono tante soluzioni diverse per risolvere questo problema, proviamo a classificarle:

#### Standard CSS e HTML

Standard CSS e HTML. Questo √® l'approccio base, che abbiamo visto che non funziona molto bene. Ovviamente per√≤ React lo supporta e
nel progetto NextJS che abbiamo creato √® la soluzione standard. Ha il vantaggio di non richiedere tool e dipendenze aggiuntive,
ed essendo nativo √® anche molto efficace. Purtroppo porta a codice che diventa difficile da mantenere in poco tempo.

#### React Style Props

Questo √® un secondo approccio nativo React, che di fatto ci permette di aggiungere una props `style`
ai nostri componenti. Questa props viene interpretata dal browser e viene utilizzata per definire il CSS. Sebbene sia nativo e semplice
da usare, ha comunque il problema che dobbiamo passare un oggetto cone le propriet√† CSS che vogliamo settare, e
in generale la development experimence non √® molto semplice.

```tsx
const MyComponent = () => (
  <div
    styles={{
      backgroundColor: "red",
      color: "white",
      fontSize: "1.5em",
    }}
  >
    Hello World
  </div>
);
```

#### Librerie grafiche

Sono delle librerie React che mettono a disposizione di noi sviluppatori dei componenti stilizzati che possiamo usare
per creare componenti. Tra le pi√π famose ci sono [Material UI](https://mui.com/) e [React Bootstra](https://react-bootstrap.github.io/).
Sono solitamente librerie molto semplici da usare per creare interfacce grafiche base, ma diventano complesse quando si vuole
fare qualcosa che va oltre quello che gli sviluppatori della libreria hanno pensato. In generale le evito in quanto, essendo
abbastanza mainstream, rendono le nostre applicazioni abbastanza monotone ed in generale troppo simili ad altre applicazioni
sparse per il web.

#### CSS in JS

Questa tecnologia consiste nell'usare CSS nativamente ma all'interno del codice HTML. Questo approccio √® molto potente
e semplice da usare, in quanto ci permette di scrivere nativamente stili in CSS ma di metterlo il pi√π vicino possibile al posto dove lo
stiamo utilizzando. Possiamo creare, nel pratico, dei componenti React con lo stile incorporato, come nel seguente esempio:

```tsx
const StyledDiv = styled.div`
  heigth: 100px;
  width: 200px;
  background-color: red;
`;
```

Tra le librerie pi√π famose che ci permettono di scrivere CSS in JS troviamo [emotions](https://emotion.sh/) e [styled components](https://www.styled-components.com/).

#### Utility CSS

Utility CSS. In questo caso l'idea √® molto semplice: quella di creare una serie di classi CSS che non contengono informazioni
semantiche (ad esempio `.card` o `.btn`) ma informazioni puramente relative allo stile che stanno per applicare (`text-red-400`, `bg-white` etc.).
Il vantaggio di questo tipo di approccio √® di nuovo quello di avere una serie di piccole classi che possono essere sfruttate
per costruire lo stile dell'HTML nello stesso posto dove definiamo l'HTML stesso. Tra le tecnologie pi√π famose e promettenti
su questo tema troviamo [`tailwindcss`](https://tailwindcss.com/), che neglio ultimi anni si √® distinta tantissmo grazie
non solo alla libreria in se ma ad una serie di tool e strumenti che migliorano notevolmente la nostra development experience.

#### Quali usare?

Quindi esistono tantissime tecnologie, quale possiamo usare? Non ho una risposto a questa domanda, perch√® come ho detto ci sono tantissimi
pareri diversi tra gli sviluppatori ed una tecnologia che piace a me pu√≤ non piacere a qualcun'altro, o viceversa.

Vi esorto quindi ad esplorarli tutti e cercare di decidere in autonomia cosa √® meglio per voi,
una conoscenza di tutti gli aprocci sarebbe ideale, ma ovviamente dobbiamo fare una scelta per questa guida, e dopo
averci pensato un po' credo che la cosa migliore sia continuare con l'approccio che conosco meglio, perch√® permetter√†
a questo corso di essere il pi√π completo possibile e non dir√≤ (troppe) castronerie üòú!

Personalmente, nei miei progetti uso un mix di TailwindUI (quindi una libreria di utility CSS), Styled component (CSS in JS) insieme
alla libreria [headlessui](https://headlessui.dev/). Quest'ultima √® un progetto degli stessi autori ci tailwind
che mette a disposizione una serie di componenti React base per interazioni standard (select, menu, etc), ma con nessuna
imposizione di stile. L'utilizzo di questa libreria in combo con tailwincss o styled component √® quindi molto vantaggiosa.

Credo che tailwind sia veramente ottima e semplice da usare, ma ha dei limiti, specialmente per quanto riguarda
la creazione di layout complessi, che invece sono facilmente compensabili con un po' di CSS in JS. In questo capito, ed in generale
nei prossimi, useremo principalmente TailindUI e un po' di CSS in JS con [emotions css](https://emotion.sh/docs/introduction) quando diventa troppo complesso usare Tailwind.

### Come trarre al meglio da questa guida?

A differenza della parte di scrittura del codice, dove √® abbastanza semplice spiegare il perch√® di certe scelte
sintattiche, la creazione e la definizione di stili grafice √® un processo che richiede molto pi√π feedback, trial and error ed
interazione con l'applicazione. In questo capitolo sar√† molto difficile per me spiegare il perch√® di alcune scelte
o da dove viene fuori un certo codice, e non credo sia possibile per me essere pi√π specifico di quanto ho fatto.

Per trarre meglio da questo capitolo suggerisco di approfondire guarda la versione video dello stesso, ed in generale vi metter√≤
alla fine del capitolo una serie di risorse utilissime per capire ed imparare l'approccio che dobbiamo avere nello
stilizzare un componente.

## Stilizziamo i componenti con TailwindCSS

Partiamo quindi subito con Tailwind e vediamo come possiamo usarla per stilizzare i componenti. Per installare e abilitare tailwind
dobbiamo fare un po' di cose sul nostro progetto. Fortunatamente, tailwind √® ben documentato e ci viene in auto una guida
per [inizializzare tailwind dentro un progetto NextJS](https://tailwindcss.com/docs/guides/nextjs).

### Installazione e configurazione di Tailwind

Installiamo quindi le dipendenze:

```bash
$ npm install -D tailwindcss postcss autoprefixer

added 33 packages, changed 1 package, and audited 335 packages in 2s

79 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
```

E inizializziamo tailwind con il comando:

```bash
$ npx tailwindcss init -p

Created Tailwind CSS config file: tailwind.config.js
Created PostCSS config file: postcss.config.js
```

Quest'ultimo comando ci ha creato due file importanti, il primo √® `postcss.config.js`, una dipendenza di tailwind
che a noi non interessa troppo. Sappiate che esiste e che senza questo tailwind non potrebbe funzionare.

Il secondo √® il file di configurazione di tailwind: `tailwind.config.js`, al cui interno possiamo inserire tutte
le personalizzazioni al progetto che vogliamo.

```js
// tailwind.config.js

module.exports = {
  content: [],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

Dentro questo file dobbiamo dire a tailwind in quali file ci aspettiamo di usare le classi che tailwind ci mette a disposizione.
Questo √® essenziale per il funzionamento di tailwind, perch√® il server tailwind monitorer√† tutti i file che inseriamo qui dentro
e generer√† il codice CSS in base alle classi che vogliamo usare. Quest'idea di tailwind ha un duplice vantaggio:

1. non creare codice CSS per utility class che non stiamo usando. Questo √® imporntate perch√® tailwind mette a disposizione
   tantissime permutazioni di classi (vedremo dopo come), e generarle tutto creerebbe file css pesantissimi che renderebbero molto
   lento il nostro progetto.
2. ci permette di utilizzare classi non previste (custom) con una sintassi particolare e generare al volo codice css per queste classi.

Dobbiamo quindi modificare questo file come segue:

```diff
// tailwind.config.js

module.exports = {
- content: [],
+ content: [
+   "./pages/**/*.{js,ts,jsx,tsx}",
+   "./pages/**/*.{js,ts,jsx,tsx}",
+ ],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

Come vedete cos√¨ facendo diciamo a tailwind di monitorare tutti i file `.js`, `.ts`, `.jsx` e `.tsx` che ci troviamo dentro
le cartelle `/pages` e `/components`. Se strutturate il vostro progetto in modo diverso da questo non √® un problema, ma ricordatevi
di modificare questo file altrimeti potreste avere problemi con il funzionamento di tailwind.

A questo punto dobbiamo creare un file chiamato `./styles/globals.css` in cui andiamo a creare le definizioni di stili globali di tailwind.

Da notare che NextJS ci ha gi√† creato questo file, con all'interno una serie di stili di default.
Possiamo cancellare tutto e, sempre d'accordo con la guida di tailwind,
andremo a mettere 3 direttive (attenzione all'ordine che √® importante):

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Queste utility non sono css standard, vengono parsate da tailwind per creare poi il vero file css.

Dato che ci siamo, cancelliamo il file `Home.module.css` che nextjs ci ha gentilmente creato che adesso non ci servir√† pi√π.

### Hello Tailwind

A questo punto siamo pronti a lanciare il progetto. Ma prima possiamo iniziare a lavorare sulla pagina iniziale `./index.tsx`.
Possiamo rimuovere tutto il contenuto della pagina e sostituirlo con quello che segue:

```tsx
const Home = () => {
  return (
    <div className="h-screen w-screen bg-red-300">
      <h1 className="text-red-800 text-xl text-center">Hello tailwind</h1>
    </div>
  );
};

export default Home;
```

Lanciando il server, a questo punto, dovremmo vedere una pagina rossa con la scritta `Hello tailwind` anch'essa rossa.

![Hello Tailwind](./hello-tailwind.png)

<InfoBox>

Tailwind non √® solamente un sistema di utility classes molto versatile. La sua popolarit√† √® dovuta anche tantissimo
ad una serie di progetti che rendono fenomenale la developer experience. Per utilizzarlo al meglio, vi suggerisco di
installare il pacchetto VSCode [Tailwind CSS IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)
che vi permette di esplorare le classi di tailwind in una forma pi√π semplice.

</InfoBox>

Ma cosa abbiamo fatto? Nella nostra pagina abbiamo creato un container div con altezza (`h-screen`) e larghezza (`w-screen`)
settate alle dimensioni dello schermo, e colore di background a _red-300_ (`bg-red-300`). All'interno di questo
componente abbiamo creato un titolo (`h1`) con il testo `Hello tailwind`, colore di testo _ted-800_ (`text-red-800`), centrato (`text-center`)
e di dimensioni _xl_ (`text-xl`). Tailwind mette a disposizione tantissime classi e tantissime gradazioni di colori, ci vuole
un attiamo per prendere familiarit√† con tutto (noi vederemo piano piano le utility che ci mette a disposizione).
Se volete avere pi√π info su Tailwind, visitate il sito [tailwindcss.com](https://tailwindcss.com/) e la [documentazione](https://tailwindcss.com/docs/utility-first/).

### Creiamo una NavBar avanzata con Tailwind

Siamo finalmente pronti a lavorare ad un componente. Per questo ho scelto di creare con tailwind la NavBar del nostro sito,
che pu√≤ sembrare un componente semplice ma in realt√† nasconde un po' di insidie come farlo collassare in modalit√† mobile
e gestire il menu a scomparsa.

Per la NavBar, quindi, insieme a Tailwind useremo altre due librerie che spesso vengono usate in coppia:

- [headlessui](https://headlessui.dev/), di cui abbiamo gi√† parlato, che ci mette a disposizie una serie di componenti
  non stilizzati e che funziona molto bene con tailwind.
- [heroicons](https://heroicons.com/), una libreria di icone creata utile per le varie icone del sito.

Per prima cosa installiamo le librerie:

```bash
$ npm i @headlessui/react @heroicons/react

added 2 packages, and audited 337 packages in 5s

79 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
```

Siamo quindi pronti per partire.

Riprediamo per prima cosa il componente `Nav` che abbiamo abbozzato precedentemente, cio√® il file che abbiamo chiamato `components/nav.tsx`, di cui
riporto il contenuto attuale:

```tsx
export const Nav = () => {
  return <nav>React Megaturial Navigation</nav>;
};
```

Per vederne il risultato, aggiungiamolo alla pagina `./index.tsx` (a cui possiamo a questo punto rimuovere il colore di background ed il testo):

```tsx
import { Nav } from "../components/nav";

const Home = () => {
  return (
    <div className="">
      <Nav />
    </div>
  );
};
```

Possiamo quindi finalmente spostarci nel file `Nav` ed iniziare a lavorare da qui.

La navbar dovr√† contenere una lista di link posizionati in vertiale, insieme ad una icona della nostra applicazione (in teoria il nostro logo
ma non avendorlo useremo l'icona delle casa) che ci rimanda
alla home del sito. Per finire, vogliamo che in modalit√† mobile la navbar collassi a solo il titolo insieme ad un pulsante che apre un menu.

In fase di design, applicare uno stile di sviluppo chiamato **mobile first**, dove l'idea di base √® quella di creare per prima cosa
il layout per cellulari (mobile appunto), e poi estenderlo alla visualizzazione desktop. Partiamo quindi a stilizzare la navbar
collassato con solo il menu e il titolo.

Partiamo dalla navbar, dobbiamo farla alta 64px `h-16` (non so perch√®, ma √® lo standard di molte navbar in giro) e di un colore
che ci piace. Partiamo quindi da dare questo stile al componente principale. Possiamo anche togliere il contenuto per
il momento.

```tsx
export const Nav = () => {
  return <nav className="h-16 bg-green-600"></nav>;
};
```

Andiamo quindi a posizionare all'interno di questa nav il nostro componente che si vedr√†
quando la navbar √® collassata (quindi in formato mobile). Per ora facciamo finta che ci sia solo questo.

Questo componente dovr√† mostrare a sinistra l'icona delle casa e a destra quella del menu. Troviamo entrambe
le icone in `@heroicons/react/outline`.

```tsx
import { HomeIcon, MenuIcon } from "@heroicons/react/outline";

export const Nav = () => {
  return (
    <nav className="h-16 bg-green-600">
      <div className="h-full flex justify-between items-center px-4 text-green-100">
        <a>
          <HomeIcon className="h-8 w-8"></HomeIcon>
        </a>
        <button>
          <MenuIcon className="h-8 w-8"></MenuIcon>
        </button>
      </div>
    </nav>
  );
};
```

Da notare che le due icone sono state wrappate la prima in un componente `<a>` (cio√® un link, infatti
deve essere un semplice link a home), mentre la seconda in un componente `<button>`, perch√® appunto
al click dovr√† aprire il menu.

Se le cose sono state fatte bene, lanciando il server, dovreste vedere qualcosa simile a questo:

![Nav 1](./nav1.png)

#### Navigazione con `next/link`

Il componente `<a>` dovr√† rimandare alla home page del sito. Questo normalmente si sarebbe fatto
in HTML con la props `href="/"`, ma NextJS ci mette a disposizione un compoente speciale
per ottimizzare la navigazione interna al sito: `Link`.

Questo componente deve sempre wrappare `<a>`, e il link `href` lo imposteremo a lui, non al componente `<a>` originale.

Questa sintassi permette a NextJS di essere pi√π veloce a renderizzare la navigazione.

```tsx
import { HomeIcon, MenuIcon } from "@heroicons/react/outline";
import Link from "next/link";

export const Nav = () => {
  return (
    <nav className="h-16 bg-green-600">
      <div className="h-full flex justify-between items-center px-4 text-green-100">
        <Link href="/">
          <a>
            <HomeIcon className="h-8 w-8"></HomeIcon>
          </a>
        </Link>
        <button>
          <MenuIcon className="h-8 w-8"></MenuIcon>
        </button>
      </div>
    </nav>
  );
};
```

#### Apertura e chiusura del menu

Per la gestione del menu le cose iniziano ad essere pi√π complesse, fortunatamente troviamo dentro `@headlessui` il
componente [`Popover`](https://headlessui.dev/react/popover) che pu√≤ essere usato, appunto, per la creazione di menu.

Partiamo quindi ad usare il Pupover per creare il nostro menu, il componente base da cui partire √® questo (preso dalla documentazione):

```tsx
import { Popover } from "@headlessui/react";

const Menu = () => {
  return (
    <Popover className="relative">
      <Popover.Button>
        <MenuIcon className="h-8 w-8" />
      </Popover.Button>

      <Popover.Panel className="absolute z-10">
        <div className="grid grid-cols-2">
          <a href="/analytics">Analytics</a>
          <a href="/engagement">Engagement</a>
          <a href="/security">Security</a>
          <a href="/integrations">Integrations</a>
        </div>
      </Popover.Panel>
    </Popover>
  );
};
```

Dove, come vedete, ho inserito il bottone ` <MenuIcon className="h-8 w-8" />` all'intenro del componente `<Popover.Button>`.

Possiamo usare il nostro menu in questo modo all'interno del componente `Nav`:

```tsx
export const Nav = () => {
  return (
    <nav className="h-16 bg-green-600">
      <div className="h-full flex justify-between items-center px-4 text-green-100">
        <Link href="/">
          <a>
            <HomeIcon className="h-8 w-8"></HomeIcon>
          </a>
        </Link>
        <div>
          <Menu />
        </div>
      </div>
    </nav>
  );
};
```

Il menu a questo punto funziona, potete provare ad aprirlo e chiderlo senza problemi, ma vi renderete subito conto che la
parte grafica non √® per niente ottimale. Iniziamo a stilizzarlo megli (in modo che almeno sia visibile) come seguie:

```tsx
const Menu = () => {
  return (
    <Popover>
      <Popover.Button>
        <MenuIcon className="h-8 w-8" />
      </Popover.Button>

      <Popover.Panel className="absolute z-10 inset-x-0 ">
        <div className="flex flex-col bg-slate-100 shadow-xl m-2 text-black">
          <a href="/analytics">Analytics</a>
          <a href="/engagement">Engagement</a>
          <a href="/security">Security</a>
          <a href="/integrations">Integrations</a>
        </div>
      </Popover.Panel>
    </Popover>
  );
};
```

Il cui risultato dovrebbe essere simile a quello che segue:

![Nav 2](./nav2.png)

#### Conditional Rendering con gli operatori `&&` e `?:`

Una cosa interessante che possiamo fare √® cambiare l'icona del menu in base al fatto che sia aperto o chiuso. Per fare questo dobbiamo
per prima cosa estrapolare una variabile che ci dice se il menu √® aperto e chiuso, e per farlo possiamo usare questa sintassi:

```tsx
const Menu = () => {
  return (
    <Popover>
      {({ open }) => (
        <>
          <Popover.Button>
            {open ? (
              <XIcon className="h-8 w-8" />
            ) : (
              <MenuIcon className="h-8 w-8" />
            )}
          </Popover.Button>

          {open && (
            <Popover.Panel className="absolute z-10 inset-x-0 ">
              <div className="flex flex-col bg-slate-100 shadow-xl m-2 text-black">
                <a href="/analytics">Analytics</a>
                <a href="/engagement">Engagement</a>
                <a href="/security">Security</a>
                <a href="/integrations">Integrations</a>
              </div>
            </Popover.Panel>
          )}
        </>
      )}
    </Popover>
  );
};
```

Come vedete, il children del pophover non √® pi√π un componente ma un render template, cio√® una funzione che prende dei
parametri e ritorna un componente.

In particolare ci interessa il parametro `open`, che appunto ci dice se il popover √® aperto o chiuso.
`open` cambia valore nel momento in cui cambiamo il bottone, o premiamo esc, ad ogni modo il suo
comportamento √® gestito dal componente `Popover`. Il nostro compito √® di usare questo componente per
far funzionare correttamente il menu.

Per prima cosa, notate che si rende necessario dire al componente quando renderizzare il `Popover.Panel`.
Quando passiamo direttamente `Popover.Panel` come children al componente `Popver`, infatti,
√® quest'ultimo che sa come e quando renderizzarlo, ma se adottiamo la sintassi con il templace children,
come stiamo facendo adesso, il componente `Popover`non prende pi√π decisioni e siamo noi che dobbiamo
dirgli di renderizzare il componente `Popover.Panel` quando `open` √® a `true`.

Per farlo usiamo questa sintassi `{open && <Popover.Panel />}`, che si chiama conditional rendering. L'operatore
`&&` semplicemente valuta se il primo valore √® `true` (o equivalente) e, in caso, ritorna il
secondo valore, altrimenti ritorna `null` (che in react vuol dire non renderizzare niente). Questa √®
una sintassi molto comune in React e quindi preparatevi a trovarla spesso in giro per i progetti.

Un altro esempio di operatore condizionale √® quello che abbiamo usato per renderizzare le icone:

```tsx
open ? <XIcon className="h-8 w-8" /> : <MenuIcon className="h-8 w-8" />;
```

In questo caso abbiamo usato il ternary operator `?:`, che non √® altro che un `if else` condensato. L'operatore
valuta il valore del primo elemento (`open`). Se √® vero ritorna il secondo elemento, altrimenti il terzo.
Quindi questa operazione si legge cos√¨:

> Se il pannello √® vero (`open==true)` allora renderizza l'icona `<XIcon />`, altrimenti l'icona `<MenutIcon />`.

Se provate a il componente a questo punto vedrete che l'icona cambia se questo √® aperto o chiuso.

#### Props del componente

A questo punto dobbiamo fare in modo da passare dall'esterno la lista di link al menu, questo √® imporante perch√® ricordiamo che dovremo renderizzare il menu in due modi diversi in base alla dimensione
dello schermo, quindi abbiamo bisogno di non dover duplicare i dati che passiamo al componente (questo √® uno dei principi
base dello sviluppo informatico chiamato **DRY** (don't repeat yourself), cio√® _non ripetere te stesso_).

Lo possiamo fare
definendo una props all'interno del nostro componente Menu:

```tsx
interface MenuElement {
  href: string;
  label: string;
}

interface MenuProps {
  menu: MenuElement[];
}
```

Da usare all'iterno del nostro menu:

```tsx
const Menu = ({ menu }: MenuProps) => {
  return (
    <Popover>
      {({ open }) => (
        <>
          <Popover.Button>
            {open ? (
              <XIcon className="h-8 w-8" />
            ) : (
              <MenuIcon className="h-8 w-8" />
            )}
          </Popover.Button>

          {open && (
            <Popover.Panel className="absolute z-10 inset-x-0 ">
              <div className="flex flex-col bg-slate-100 shadow-xl m-2 text-black">
                {menu.map((item, idx) => (
                  <Link key={idx} href={item.href}>
                    <a>{item.label}</a>
                  </Link>
                ))}
              </div>
            </Popover.Panel>
          )}
        </>
      )}
    </Popover>
  );
};
```

Quello che abbiamo fatto √® stato usare la lista `menu` per renderizzare i link con l'espressione `menu.map()`, che ricordo ci permette
di creare una lista di elementi (in questo caso `<Link />`) a partire da una lista di partenza (contenente i dati).

Invece di listare quindi i link come facevamo prima

```tsx
<a href="/analytics">Analytics</a>
<a href="/engagement">Engagement</a>
<a href="/security">Security</a>
<a href="/integrations">Integrations</a>
```

adesso facciamo un loop all'interno di `menu` (che ci arriva da fuori) e generiamo un oggetto `<Link />` per ognuno di questi elementi.

Per usare il nuovo componente, dobbiamo creare la lista:

```tsx
const MenuElements: MenuElement[] = [
  {
    href: "/blog",
    label: "Blog",
  },
  {
    href: "/about",
    label: "About",
  },
];
```

E passarla in fase di renderizzazione al componente:

```tsx
<Menu menu={MenuElements} />
```

ed il risultato dovrebbe essere il seguente:

![nav 3](./nav3.png)

#### Creare nuove pagine

Siamo pronti a testare che la navigazione funzioni, ma per farlo ci servono nuove pagine. La creazione delle nuove pagine
`/about` e `/blog` √® semplicissima: basta creare due file `pages/about.tsx` e `pages/blog.tsx`, con il seguente contenuto:

```tsx
// pages/about.tsx
import { Nav } from "../components/nav";

const About = () => {
  return (
    <div className="">
      <Nav />
      <h1> About</h1>
    </div>
  );
};

export default About;
```

```tsx
// pages/blog.tsx
import { Nav } from "../components/nav";

const Blog = () => {
  return (
    <div className="">
      <Nav />
      <h1> Blog</h1>
    </div>
  );
};

export default Blog;
```

Fatto questo, dovremmo poter essere in grado di navigare tranquillamente all'intenro della nostra app!

#### Breakpoints e Modalit√† Desktop

Ora che la modalit√† mobile funziona bene, dobbiamo creare l'applicazione in modo che il menu venga visualizzato diversamente
in modalit√† desktop. Per farlo, dobbiamo introdurre il concetto di breakpoin in Tailwind.

Un breakpoint non √® altro che una dimensione dello schermo in larghezza per cui una pagina pu√≤ cambiare layout.
Tailwind mette a disposizione di default una [serie di breakpoint](https://tailwindcss.com/docs/responsive-design), chiamate `xl`, `sm`, `md` e `lg` etc.
Questi breakpoint si traducono in modificatori delle classi css che ci permettono di cambiare il layour in base
alla dimensione dello schermo. Vediamo come usarli.

L'idea di base dei modificatori di tailwind √® che possiamo applicare nuovi template sovrascrivendo le classi a brackpoint diverse.
Facciamo un esempio per capire meglio: supponiamo di voler nascondere il menu del nostro header quando lo schermo √® a breackpoint `md` (medium)
o superiori, per farlo basta usare questa sintassi:

```tsx
<div className="md:hidden">
  <Menu menu={MenuElements} />
</div>
```

Il bottone sar√† mostrano normalemnte fino al breackpoint `md`, e poi verr√† applicato la classe `hidden` che non lo far√† pi√π vedere.

Per fare il contrario, dobbiamo creare un componente `hidden` di base e poi mostrarlo al breackpoint `md`:

```tsx
<div className="hidden md:block">Visibile la breakpoing</div>
```

Mettendo insieme questi due componenti, vedrete che quando il primo sparisce il secondo appare!

#### Creazione della navbar estesa

Andiamo quindi a sfruttare questa funzionalit√† per creare la navbar estesa, che metteremo all'interno del nostro `<div>` visibile
solo in modalit√† desktop.

```tsx
const DesktopMenu = ({ menu }: MenuProps) => {
  return (
    <ul className="flex gap-2">
      {menu.map((item, idx) => (
        <li key={idx}>
          <Link href={item.href}>
            <a>{item.label}</a>
          </Link>
        </li>
      ))}
    </ul>
  );
};
```

Il componente prende le stesse props di `<Menu />`, ma invece di renderizzare il bottone con il popup, renderizza una
semplice list di `<Link />` orizzonatale.

Il componente `Nav` finale, quindi, risulta essere il seguente:

```tsx
export const Nav = () => {
  return (
    <nav className="h-16 bg-green-600">
      <div className="h-full flex justify-between items-center px-4 text-green-100">
        <Link href="/">
          <a>
            <HomeIcon className="h-8 w-8"></HomeIcon>
          </a>
        </Link>
        <div className="hidden md:block">
          <DesktopMenu menu={MenuElements} />
        </div>
        <button className="md:hidden">
          <Menu menu={MenuElements} />
        </button>
      </div>
    </nav>
  );
};
```

Questo dovrebbe essere il risultato finale:

![Desktop Nav](./desktop.png)
![Mobile Nav](./mobile.png)

## Stilizziamo i componenti con emotions

Abbiamo visto come usare TailwindCSS e le sue funzionalit√† per creare una navbar in grado di collassare. Facciamo anche un accenno
agli styled component che potremmo trovare

Partiamo subito con la libreria di css-in-js chiamata [emotions](https://emotion.sh/docs/introduction) ed iniziamo a stilizzare la nostra navbar.
Per farlo, per prima cosa dobbiamo installare la libreria, dato che, come abbiamo detto, vogliamo utilizzare gli styled components, dovremmo
installare due pacchetti: `@emotion/styled` e `@emotion/react`:

```bash
$ npm i @emotion/styled @emotion/react

added 72 packages, and audited 302 packages in 20s

71 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
```

Con questa libreria andremo a stilizzare la navbar della nostra applicazione, cio√® il file che abbiamo chiamato `components/nav.tsx`, di cui
riporto il contenuto attuale.

```tsx
export const Nav = () => {
  return <nav>React Megaturial Navigation</nav>;
};
```

La navbar dovr√† contenere una lista di link posizionati in vertiale, insieme ad un titolo della nostra appliazioche che ci rimanda
alla home del sito. Per finire, vogliamo che in modalit√† mobile la navbar collassi a solo il titolo insieme ad un pulsante che apre un menu.

In fase di design, applicare uno stile di sviluppo chiamato **mobile first**, dove l'idea di base √® quella di creare per prima cosa
il layout per cellulari (mobile appunto), e poi estenderlo alla visualizzazione desktop. Partiamo quindi a stilizzare la navbar
collassato con solo il menu e il titolo.

Partiamo prima di tutto dal contenuto. Il nostro componente `<nav>` dovr√† contenere un `<div>` con all'interno due componenti,
il titolo ed un bottono:

```tsx
export const Nav = () => {
  return (
    <nav>
      <div>
        <span>RMT</span>
        <button> menu </button>
      </div>
    </nav>
  );
};
```

Siamo pronti quindi a stilizzare il componente.

La cosa che faccio di solito √® creare un componente interno dove inserire lo style utilizzando `@emotions/styled`. Dato che il momponente
princiaple della nostra navbar √® l'oggetto html `<nav>`, partir√≤ da questo per generare l'oggetto stilizzato.

```tsx
import styled from "@emotion/styled";

export const Nav = () => {
  return (
    <NavStyled>
      <div>
        <span>RMT</span>
        <button> menu </button>
      </div>
    </NavStyled>
  );
};

const NavStyled = styled.nav`
  height: 60px;
  background-color: #ccc;
  color: white;
`;
```

Come vedete il componente `NavStyled` non √® altro che un classico componente `<nav>` HTML a cui abbiamo _appiccicato_ dello style
con styled componente. Per farlo abbiamo importato la libreriea `styled` da `@emtion/styled` e abbiamo
usato una speciale sintassi in JavaScript chiamata [**tag functions**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals?retiredLocale=it#tagged_templates) (o **tagged templates**),
che non sono altro che delle speciali funzioni seguite da un template literal.

<InfoBox>
`@emotion/styled` √® molto potente in quello che ci permette di fare, ed in generare √® possibile creare styled component
anche a partire da componenti custom React, con una sintassi di questo tipo:

```tsx
const MyCompoent = () => <div></div>;

const MyComponentStyled = styled(MyCompoent)`
  background-color: #ccc;
`;
```

ma non mi voglio addentrare in questi dettagli. In questa guida useremo soltanto la sintassi che abbiamo visto con i componenti
nativi HTML.

</InfoBox>

Ora che abbiamo la base del nostro componente possiamo lanciare il server `npm run dev` e accedere al solito link `http://localhost:3000/experiments`
per vedere il risultato.

![Nav 1](./nav1.png)

Il risultato √® un po' bruttino, ma almeno abbiamo un componente che pu√≤ essere stilizzato.

<InfoBox>
Siccome stiamo lavorando in mobile mode, conviene mettere il browser in visualizzazione mobile per avere una view simile a quella di un telefono.
Per farlo basta aprire l'inspector del browser e cliccare sull'icona a forma di telefono/tablet che trovate in alto a sinistra dell'
inspector, all'inizio della navbar principale

</InfoBox>
