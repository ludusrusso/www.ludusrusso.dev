// autogenerated by /Users/ludovicorusso/develop/github.com/ludusrusso/www.ludusrusso.dev/scripts/build-courses.ts. Do not edit!

export type Course = typeof courses[number]
export type CourseChapter = Course["frontMatter"]["toc"][number]
export const getCourses = () => courses
export const getCourse = (slug: string) => courses.find(course => course.slug === slug)
export const getCourseChapter = (slug: string, cslug: string) =>
  courses
    .find((course) => course.slug === slug)
    ?.frontMatter.toc.find((chapter) => chapter.slug === cslug);

const courses = [
  {
    "file": "/Users/ludovicorusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/index.mdx",
    "content": "\nNextJS e React sono dei tool molto usati nel mondo dello sviluppo web moderno. Chiunque voglia diventare\nuno sviluppatore web può puntare su questi progetti per iniziare ad imparare e sviluppare i propri progetti.\n\nQuesto corso, raccolto qui come un lungo e completo tutorial, è un mio piccolo esperimento per iniziare\nla scrittura di un libro completo ed introduttivo rivolto a persone che vogliono avvicinarsi in modo completo\nal mondo dello sviluppo web.\n\nIl corso sarà composto di una serie di capitoli con materiale misto tra video tutorial e materiale scritto. Inoltre,\nla parte scritta di questo corso sarà resa gratuitamente disponibile all'interno del mio blog per\nchiunque voglia visualizzarlo.\n\nIl corso è in fase di scrittura, e chiedo a chi lo seguirà di darmi il più possibile feedback e suggerimenti per renderlo\npiù completo e più utile ai più. A breve, inoltre, renderò possibile agli interessati ad iscriversi al corso\nper accedere a tutto il materiale che sto producendo ad un prezzo vantaggioso! Quindi rimanete sintonizzati\nsu questo blog per saperne di più!\n\n## Introduzione\n\nBenvenuti nel mio progetto **NextJS Mega Tutorial**!\nIn questa serie di articoli voglio condividere la mia esperienza nello sviluppo reale di applicazioni con NextJS e Javascript.\nInsieme vederemo come sviluppare e deployare applicazioni complete usando NextJS, React e l'ecosistema Javascript.\n\nA differenza di molte altre risorse e tutorial che si trovano in rete, **NextJS Mega Tutorial** vi porterà all'interno di\nun viaggio nello sviluppo software completo. Insieme non vedremo esempi isolati, ma vi mostrerò qual è il processo completo\nper sviluppare applicativi web completi e non banali.\nQuando raggiungeremo la fine del viaggio, avremmo sviluppato insime un progetto completo di cui conoscerete ogni linea di codice.\nCosa più importante, capirete nel dettaglio tutte le tecnologie, i concetti e le tecniche che utilizzano gli sviluppatori\nprofessionali per creare progetti complessi, e sarete in grado di applicare questi concetti ai vostri progetti personali e lavoriativi.\n\n## Prerequisiti\n\nPer ottenere il massimo da questa serie di tutorial devi avere una minima esperienza nello\nsviluppare applicativi con Javascript. Se hai sviluppato siti internet (o parti di questi)\nusando _Vanilla Javascript_ o librerie come _JQuery_ dovrebbe andare bene.\n\nUna minima conoscenza di HTML e CSS è anchenecessaria. Come nel caso di Javascript, una\nesperienza base con queste tencologie è sufficiente. Io assumo che tu sappia come creare\nuna semplice pagina HTML usando elementi come `<p>`, `<h1>`, `<img>` e `<div>`, e come usare\nCSS per applicare stili a questi elementi.\n\nUna conoscenza base della command line del sistema operativo è anche utile.\nPasseremo la maggior parte del tempo ad implementare codice nell'editor di testo, ma alcune\noperazioni devono necessariamente essere eseguite dalla commmand line del sistema operativo.\n\nSe usi Windows, consiglio di usare [il sottosistema Windows per Linux](https://docs.microsoft.com/it-it/windows/wsl/about),\nche mette a disposizione una bash compatibile con i comandi UNIX e bash, node.js e gli altri comandi che utilizzeremo. Usare\nwindows con PowerShell è possibile ma richiederà alcune modifiche alla command line rispetto a quelle che userò io in questa serie\ndi tutorial. Su Mac o Linux potete usare il terminale integrato nel sistema operativo.\n\nCome editor di testo per scrivere consiglio di usare [Visual Studio Code](https://code.visualstudio.com/), l'editor di testo\ndi riferimento per lo sviluppo software (specialmente in ambito web), che potete scaricare gratuitamente dal sito su tutte le piattaforme.\n\nPer testare l'applicazione che svilupperemo, potete usare il vostro browser preferito.\nIl mio cosiglio è di usare Chrome o Firefox, che sono i browser più usati per lo sviluppo web, in quanto sono\ncompatibili con il plugin [React Developer Tool](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi),\nmolto utile per fare debug delle applicazioni React (la libreria grafica alla base di NextJS).\n\nQuesto corso sarà a disposizione in una combinazione di materiale in forma scritta e video. Il corso è a pagamento ma la parte\nscritta del tutorial è anche disponibile gratuitamente su questo blog.\n\nPronto per iniziare? Il primo capitolo ti aspetta!\n",
    "slug": "nextjs-mega-tutorial",
    "frontMatter": {
      "toc": [
        {
          "file": "/Users/ludovicorusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/00001-javascript-moderno/index.mdx",
          "content": "\nIl linguaggio di programmazione JavaScript è evoluto tantissimo negli ultimi\nanni. Purtroppo, siccome i browser sono lenti ad adottare le nuove funzionalità e\ncambiamenti, molti sviluppatori non sono riusciti ad aggiornarsi sulle nuove funzionalità.\n\nReact (e quindi NextJS) incoraggiano gli sviluppatori ad usare le funzioni moderne di JavaScript,\nper questo motivo questo capitolo è incentrato su un piccolo aggiornamento delle principali\nfeatures di JavaScript moderno che andremo ad utilizzare durante questo corso.\n\n## ES5 vs ES6\n\nJavaScript è un linguaggio basato sulla specifica ECMAScript, mantenuta da [ECMA](https://www.ecma-international.org/), un'organizzazione\nnon-profit che si occupa di mantenere e gestire standard legati al mondo dell'informatica e dei sistemi di telecomunicazione.\n\nNel mondo JavaScript spesso vengono citati termini come _ES5_ e _ES6_ relative alla versioni\ndel lingaggio. Questi termini si riferiscono rispettivamente alle versioni 5 e 6 della specifica ECMAscript\ndefinite da ECMA. _ES5_ è stata rilasciata nel 2009 ed è considerata attualmente\nla versione base delle varie implementazioni, in quanto è supportata da una stragande maggioranza\ndi browser e sistemo mobile. _ES5_, invece, è stata rilasciata nel 2015. Questa versione introduce\ndiverse migliorie significative alla versione pricedente, e rimane compabile con _ES5_ (cioè un\nquasiasi programma implementato in _ES5_ può essere eseguito da un interprete _ES6_, ma non viceversa).\n\nDalla verisone _ES6_ in avanti, ECMA ha deciso di rilasciare aggiornamenti periodici (ogni anno)\nalle specifica, per questo motivo spesso con _ES6_ ci si riferisce a tutti i miglioramenti\nrilasciati dalla versione _ES6_ in avanti, quindi spesso il termine _ES6_ è usato non propriamente\nper indicare la versione _ES6_, ma per indicare tutte l'ultimo pacchetto di aggiornamenti rilasciati nell'anno in corso (si lo so,\nconfonde un po').\n\nCome fanno quindi i Browser a stare dietro un'evoluzione tanto rapida? Non lo fanno e non potrebbero farlo. Le ultime\nfeature rilasciate nelle versioni _ES6_ e i suoi aggiornamenti non sono garantiti essere implementati in tutti i browser.\nPer gli sviluppatori questo è un problema, perchè non hanno controllo sul tipo di browser su cui la loro applicazione\nverrà eseguita. Ci viene però incontro una tecnica chiamata [**transpiler**](https://en.wikipedia.org/wiki/Source-to-source_compiler),\nche consiste nel convertire programmi scritti in una versione moderna di JavaScript in una versione equivalente scritta\nutilizzando _ES5_ che garantisce una compatibilità con (quasi) tutti i browser. I transpiler sono integrati in tutti\ni principali framework moderni JavaScript (e quindi in React a NextJS che usere in questo corso), e grazie a questi\ngli sviluppatori hanno molti meno vincoli e possono tranquillamente utilizzare le ultime feature di _ES6_.\n\n## Una carrellata delle Features moderne di JavaScript\n\nQuesto corso si basa su _ES6_, quindi mi sembra utile fare una breve carrellata, prima di iniziare, delle feature\npiù importanti che useremo di JavaScript e delle convezioni (in questo caso mie prefernze) che useremo per scrivere\ni vari programmi in questo corso.\n\n### Semicolon (punto e virgola) `;`\n\nLe regole di JavaScript riguardo quando usare il `;` sono poco chiare e spesso\nconfondono gli sviluppatori. Si dice che JavaScript, a differenza di altri linguaggi,\nnon richieda l'uso dei `;` per separare le istruzioni. Questo non è propriamente\nvero. Sebbene non sia necessario la maggior parte delle volte, in specifici casi\nil loro utilizzo è richiesto, e questo spesso porta a bug o ad un codice che si\ncomporta in modo diverso da quello che vogliamo.\n\nPer evitare questi problemi, io (e molti programmatori JavaScript) consiglio di\nusare sempre il `;` per chiudere le istruzioni. Non utilizzo il `;` dopo il\nsimbolo `}` alla fine di una dichiarazione di funzione o di un blocco di codice di una\nstruttura di controllo (come `if`, `for`, ecc.) in quanto è la prassi per molti\naltri linguaggi come `C/C++` e `Java`.\n\nEcco alcuni esempi:\n\n```javascript\nconst myVar = 1; // <- termine di un'istruzione di assegnazione\n\nfunction myFunc() {\n  console.log(\"funzione\"); // <- termine di un'istruzione di esecuzione\n} // <- qui non serve perchè chiude una dichiarazione di funzione\n```\n\nAttenzione a quando viene assegnata una funzione anonima (arrow function) ad una variable, in questo caso\nil `;` è necessario dopo il `}` per chiudere l'assegnazione.\n\n```javascript\nconst myFunc = () => {\n  console.log(\"funzione\");\n}; // <- termine di un'istruzione di assegnazione\n```\n\nOvviamente queste sono preferenze e consigli di stile adottati da molti sviluppatori (non tutti),\nquindi non è necessario che seguiate queste regole, ovviamente se sapete bene cosa state facendo.\n\nNon è nemmeno necessario ricordarle perfettamente, in quanto esistono tools, come prettier, che ci aiutano\nad uniformare lo stile in fase di scrittura. Vedremo in futuro come usarle.\n\n### Trailing commas (virgole finali)\n\nQuando definiamo un oggetto o un array su più di una linea, è molto utile inserire una virgola\nanche dopo l'ultimo elemento.\nQuesta sintassi può sembrare scorretta ma JavaScript (insieme a molti altri linguaggi come Go ad esempio)\nlo permettono.\n\nEcco alcuni esempi:\n\n```javascript\nconst myArr = [\n  1,\n  2,\n  3, // <- virgola qui\n];\n\nconst myObj = {\n  name: \"Ludovico\",\n  age: 33, // <- virgola qui\n};\n```\n\nCi sono due vantaggi ad usare questa sintassi:\n\n1. Possiamo spostare tutti gli elementi senza preoccuparti di rompere la sintassi,\n2. Quando dobbiamo aggiungere un nuovo elemento alla fine, lo possiamo fare senza preoccuparci di aggiungere la virgola all'elemento precedente.\n\n### Import ed export\n\nSe sei abituato a scrivere applicazioni _old-style_ in JavaScript per il browser, probabilmente\nnon hai mai abuto bisogno di importare o esportare codice javascript. Potevi semplicemente\nrichiedere al browser di caricare i file javascript usando il tag `<script>` in HTML.\nIn questo modo tutte le definizioni e le funzioni dichiarate nel codice è accessibile\ntramite come scope _globale_ all'interno della pagina nel browser.\nSebbene questo approccio funzioni, non è facilmente mantenibile e diventa un problema per\ngrossi progetti.\n\n_ES6_ introduce il concetto di _modulo_, cioè un insieme di funzioni e variabili che sono accessibili\ntramite _import_ ed _export_ all'interno di altri file. Grazie ai moduli il programmatore può controllare\nil codice da esportare e mettere a disposizione ad altri programmatori dal codice interno al modulo stesso.\n\nUn modulo JavaScript non è altro che un file javascript che contiene una serie di definizioni di funzioni, variabili e altri oggetti.\nDi default tutto ciò che è dichiarato all'interno del modulo è privato, cioè non è accessibile dall'asterno.\nSe però vogliamo esportare (quindi rendere pubblico) una di queste definizioni possiamo usare al keyword `export`:\n\n```javascript\n// myModule.js\n\nexport function myFunction() {\n  console.log(\"funzione esportata\");\n}\n```\n\nE importarla (per usarla) in un altro file con la keywork `import`\n\n```javascript\n// main.js\n\nimport { myFunction } from \"./myModule\";\n\nmyFunction();\n```\n\nLa sentassi che stiamo usando per importare si chiama _unpacking_, e ci permette di\nselezionare quali definizioni vogliamo importare dal modulo. Se sono più di una è possibile\nusare la virgola per listarle all'interno delle parentesi graffe.\n\nJavascript ci da anche la possibilità di esportare una definizione con la keyword `export default`,\nper ogni modulo possiamo solo esportare un oggetto usando `default`, e la sintassi per importarla\nnon prevedere le parentesi, come in questo caso\n\n```javascript\n// secondoModule.js\n\nexport default function mySecondFunction() {\n  console.log(\"funzione esportata usando default\");\n}\n\n// main.js\n\nimport mySecondFunction from \"./secondModule\";\n\nmySecondFunction();\n```\n\nIn questo caso possiamo decidere arbitrariamente il nome della funzione quando la importiamo, ad esempio\navremmo potuto scrivere\n\n```javascript\n// main.js\n\nimport myFunc from \"./secondModule\";\n\nmyFunc();\n```\n\nPossiamo anche usare contemporaneamente le due sintassi `export default` ed `export`, esattamente con le\nregole di prima.\n\n```javascript\n// multipleModule.js\n\nexport const PI = 3.14;\nexport const sqrt = (x) => {\n  return Math.sqrt(x);\n};\n\nexport default function circleArea(r) {\n  return PI * r * r;\n}\n\n// main.js\n\nimport circle, { PI, sqrt } from \"./multipleModule\";\n\n// oppure\n\nimport circle from \"./multipleModule\";\nimport { PI, sqrt } from \"./multipleModule\";\n```\n\nChiamando la funzione `myFunc`. Alcune librerie e framework JavaScript (come React ad esempio),\nconsigliano di utilizzare principalmente la sintassi con `export default`. Io in generale (ma questa è una mai\npreferenza) preferisco la sintassi con `export` normale, per due motivi:\n\n1. Ci permette di esportare più dichiarazioni dallo stesso file,\n2. Funziona meglio con tools di sviluppo che non supportano la sintassi `export default`.\n\nSe volete saperne di più, vi suggerisco di leggere le sezioni\n[import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) ed\n[export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) della documentazione di JavaScript.\n\n### Variabili\n\nOgni linguaggio di programmazione ha alla base il concetto di variabile, cioè simboli all'interno dei\nquali vengono salvate dei valori.\n\nAnche in questo caso, le versioni vecchie di JavaScript erano _incasinate_ (non so come dirlo in modo carino)\nsulla definizione di variabile. In particolare l'unico modo per definire una variabile era usare\nla keyword `var`, che però aveva un comportamento molto diverso rispetto agli altri principali linguaggi di\nprogrammazione. Non voglio entrare nel merito di questo, però l'utilizzo di `var` faceva si che il codice\nfacesse come strane come dare la possibilità di utilizzare una variabile prima della dichiarazione, che ovviamente\nportava a bug e problemi di comportamento nei programmi.\n\nPer ovviare a questo, _ES6_ ha introdotto due nuovi keywords: `let` e `const`, per la definizione di variabile, lasciando\n`var` per ragioni di retrocompatiblità ma con la forte raccomandazione di non usare più questa keyword. In generale\nla community JavaScript è abbastanza d'accordo sul fatto che `var` non debba proprio essere usata all'interno dei programmi.\n\nPer definire una variable, usiamo quindi la keywork `let`:\n\n```javascript\n// definiamo la variabile a\nlet a; // valore undefined\n\na = 10; // valore 10\n\n// definiamo e assegnamo un valore alla variabile b\nlet b = 1;\n```\n\nSe una variable è definita ma non assegnata con `let`, il suo valore di default sarà `undefined`.\n\nUna costante è una variabile che può essere assegnata solo nel momento della definizione, e non più dopo.\nTentare di riassegnare una variabile definita con `const` porterà ad un errore.\n\n```javascript\nconst c = 10;\n\nconsole.log(c);\n// Output: 10\n\nc = 11; // errore\n// Output: Uncaught TypeError: Assignment to constant variable.\n```\n\nMi piace parlare comunque di variabile e non di costante, perchè è possibile assegnare oggetti mutabili (cioè il cui valore\ncambia nel tempo, ad una variabile definita con `const`). Questo può sembrare un po' confusionario le prime volte, quindi vediamo\nun esempio:\n\n```javascript\nconst myArr = [1, 2, 3];\n\nmyArr.push(4);\n\nconsole.log(myArr);\n// Output: [1,2,3,4]\n```\n\nQuesto codice è lecito e funzionante, quello che non possiamo fare è riassegnare `myArr`. In generale\nuna variable `const` in JavaScript non può mai stare (se non la prima volta) a sinistra dell'istruzione di assegnazione\n`=`, e quindi non può essere riassegnata.\n\n```javascript\nmyArr = [1, 2]; // errore\n// Output: Uncaught TypeError: Assignment to constant variable.\n```\n\nPer maggiori informazioni potete consultare la documentazione di JavaScript per [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) e [`const`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const).\n\n### Comparazioni in JavaScript\n\nAnche in questo caso, le versioni vecchie di JavaScript erano un casino per quanto riguarda le istruzioni di comparazione,\ne con _ES6_ si è riusciti (finalmente) a mettere un po' di ordine.\n\nIn particolare, gli operatori originali di comparazione `==` e `!=` sono stati creati nuovi operatori: `===` e `!==`, che hanno un comportamente\nmatematicamente molto più corretto.\nGli operatori originali sono stati lasciati per retrocompatibilità, ma è consigliato usare gli operatori nuovi.\n\nAnche in questo caso non mi voglio dilungare troppo e vi dico solo di evitare sempre di usare `==` e `!=` per non\nincappare in bug e comportamente strani nel codice.\n\nVediamo come usarli:\n\n```javascript\nconst a = 1;\n\nconsole.log(a === 1); // Output: true\nconsole.log(a === \"1\"); // Output: false\nconsole.log(a !== 3); // Output: true\n```\n\nSiccome molti linguaggi di programmazione usano `==` e `!=` come operatori di comparazione,\nsuccede spesso di confonderli ed è quasi inevitale l'uso degli operatori originali nel codice.\nPer questo motivo consiglio vivamente (vedremo dopo come farlo) di installare un analizzatore di codice\nnel nostro editor di testo che ci avvertenga quando usiamo `==` e `!=`.\n\nPer ulteriori dettagli, consultate la documentazione di JavaScript per gli operatori [`===`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality) e [`!==`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_inequality).\n\n### Interpolazione di Stringhe\n\nQuando dobbiamo costruire una string a partire dal valore contenuto in una variabile,\npossiamo usare un'utilizza funzione di _ES6_ chiamata _template literals_.\n\nEcco un esempio:\n\n```javascript\nconst name = \"Ludovico\";\nconst saluti = `Ciao, ${name}!`;\n\nconsole.log(saluti);\n// Output: Ciao, Ludovico!\n```\n\nQuesta sintassi si usa all'interno di una stringa definita con il carattere ``` (backtick).\n\nPurtroppo per noi italiani non è semplice digitarlo sulla tastiera, in quanto non è un carattere che\nsolitamente usiamo. Sul mac (che uso io), si ottiene premente i tast `option + 9`, su linux possiamo usare\n`ALT + '` (ALT + apostrofo), mentre su windows digitando `ALT+96` (ALT e poi i caratteri `9` e `6`).\n\nTrovate più info sui _template literals_ sulla [doc apposita](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).\n\n### Cicli for\n\nIn JavaScript, è possibile definire un ciclo for in modo simile agli altri linguaggi, usando la sintassi\n\n```javascript\nfor (let i = 0; i < 3; i++) {\n  console.log(`i = ${i}`);\n}\n// Output:\n// i = 0\n// i = 1\n// i = 2\n```\n\nTuttavia, le versioni _ES6_ introduce un utile ciclo `for of`, che permette di iterare all'interno dei valori di un array\n\n```javascript\nconst names = [\"Ludo\", \"Silvia\", \"Carlo\"];\nfor (let name of names) {\n  console.log(`Ciao, ${name}!`);\n}\n// Output:\n// Ciao, Ludo!\n// Ciao, Silvia!\n// Ciao, Carlo!\n```\n\nAttenzione a non confonderlo con il `for in`, che itera all'interno delle `chiavi` un oggetto o array.\n\n```javascript\nconst names = [\"Ludo\", \"Silvia\", \"Carlo\"];\nfor (let id in names) {\n  console.log(`[${id}]: Ciao, ${names[id]}!`);\n}\n// Output:\n// [0]: Ciao, Ludo!\n// [1]: Ciao, Silvia!\n// [2]: Ciao, Carlo!\n```\n\n### Arrow function\n\n_ES6_ introduce una seconda per definire le funzioni, chiamate _arrow function_ o _fat arrow functions_.\n\nPer fare un esempio, consideriamo la funzione così definita:\n\n```javascript\nfunction mult(x, y) {\n  const res = x * y;\n  return res;\n}\n\nmult(2, 4); // Output: 8\n```\n\nCon la nuova sintassi possiamo definire la funzione in questo modo\n\n```javascript\nconst mult = (x, y) => {\n  const res = x * y;\n  return res;\n};\n\nmult(2, 4); // Output: 8\n```\n\nSebbene non sembri che cambi tanto, e i due modi possono sembrare ridondanti all'inizio. Questa seconda sintassi\npermette di scrivere codice più pulito e più conciso. Infatti, per funzioni che hanno una sola istruzione\nall'interno possiamo evitare le parentesi graffe e il `return`, riscrivendola così:\n\n```javascript\nconst mult = (x, y) => x * y;\n\nmult(2, 4); // Output: 8\n```\n\n```javascript\nconst PI = 3.14;\nconst circleArea = (r) => PI * r * r;\n\ncircleArea(2); // Output: 12.56\n```\n\nInoltre, le arrow functions permettono di avere una sintassi molto più pulita quando sono usate\ncome funzioni anonime passate come parametro ad altre funzioni. Per capire meglio facciamo un esempio.\n\nIn JavaScript è possibile creare un array a partire da un array originale usando la funzione `map`. Questa\nfunzione, di fatto, prende un array, esegue una seconda funziona a tutti gli elementi dell'array originale\ne ritorna un nuovo array con i risultati delle varie computazioni.\n\nQuesta sintassi\n\n```javascript\nconst nums = [1, 2, 3, 4, 5];\n\nconst doubleNums = nums.map(function (n) {\n  return n * 2;\n});\n// Output: [2, 4, 6, 8, 10]\n```\n\nPuò essere sostituita con la seguente che è molto più leggibile e concisa:\n\n```javascript\nconst nums = [1, 2, 3, 4, 5];\n\nconst doubleNums = nums.map((n) => n * 2);\n// Output: [2, 4, 6, 8, 10]\n```\n\nPer approfondire eccola la documentazione delle [arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).\n\n### Promise\n\nIn JavaScript, quasi tutte le operazioni che coinvolgono la comunicazione con qualcosa di esterno al programma (una chiamata network,\naccesso al filesystem, ecc) sono asincrone. Il termine vuol dire che il programma non viene bloccato mentre\naspetta la risposta e può continuare a fluire. Il meccanismo che usa JavaScript per modellare questo comportamento\nsono le _promise_.\n\nUna promise è un oggetto _proxy_ che viene ritornato da un'operazione asincrona. L'oggetto non contiene\nil risultato dell'operazione, ma ci permetterà di accedere al risultato una volta che l'operazione sarà terminata.\n\nL'accesso al risultato avviene tramite una funzione di callback, in particolare l'oggetto `Promise` mette a disposizione\ndue metodi principali: `then()` e `catch()`. Entrambi i metodi richiedono come unico parametro una funzione di callback:\n\n- La funzione che passiamo tramite `then()` viene eseguita nel momento in cui il risultato risulta disponibile.\n- La funzione che passiamo tramite `catch()` viene invece eseguita se l'operazione fallisce, e ci permette di gestire l'errore.\n\nTantissime librerie JavaScript (sia interne che di terze parti) fanno fortemente uso delle primise, per questo dobbiamo\ncapire bene il loro meccanismo.\n\nPartiamo con un esempio: il browser ci mette a disposizione una funzione `fetch` per fare chiamate http ad URL specifici.\nQuesta funzione ritorna una promise:\n\n```javascript\nfetch(\"https://jsonplaceholder.typicode.com/users/1\").then((res) =>\n  console.log(res)\n);\n```\n\nQuesta funzione esegue la chiamata `GET https://jsonplaceholder.typicode.com/users/1` in background (quindi senza bloccare il programma).\nNel momento in cui la chiamata ritorna un risultato, questo risultato viene passato alla funzione di callback dichiarate nel `then()` che\nlo stampa a video.\n\nLe promesse possono essere eseguite in sequenza (si dice `chained` in inglese) ritornando un'altra promise\nnella funzione di callback. Un caso molto comune è il seguente:\n\n```javascript\nfetch(\"https://jsonplaceholder.typicode.com/users/1\")\n  .then((r) => r.json())\n  .then((data) => console.log(data));\n```\n\nIn questo caso la prima promise è la chiamata http, e la funzione di callback di questa esegue il metodo `r.json()`: questo\nmetodo si occupa di convertire il risultato in un oggetto JSON e ritorna una promise per gestire il risultato una volta disponiible.\nQuesta seconda Promise viene quindi gestire tramite il secondo `then()` che stampa a video il risultato.\n\nPer gestire l'errore, possiamo invece usare il metodo `catch()`, come in questo caso:\n\n```javascript\nfetch(\"https://jsonplaceholder.typicode.com/users/1\")\n  .then((r) => r.json())\n  .then((data) => console.log(data));\n  .catch((err) => console.error(`Got and error: ${err}`));\n```\n\nLe promise mettono a disposizione anche altri metodi per gestirle ed eseguirne più di una contemporaneamente.\nPer maggiori informazioni vi lascio [alla documentazione](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n### `async` e `await`\n\nLe _promise_ offrono un'ottima astrazione per gestire le operazioni asincrone all'interno del codice JavaScript, ma\nil loro uso massiccio, specialmente in casi di una lunga catena di promises all'interno di varie chiamate del metodo `then()`,\nporta alla scrittura di codice difficile da capire e mantenere.\n\nPer questo, nel 2017, ECMAScript ha introdotto una nuova sintassi per gestire le promise, tramite le keywork `async` e `await`.\nGrazie alla nuova sintassi, possiamo definire una funzione come asincrona con la keywork `async`. Le funzione asincrone\nritorneranno sempre una promise, e al loro interno è possibile usare la keyword `await` per attendere il risultato della promise senza\nusare il metodo then.\n\nEcco un esempio del codice precedente gestiro con la nuova sintassi:\n\n```javascript\nasync function fetchData() {\n  const r = await fetch(\"https://jsonplaceholder.typicode.com/users/1\");\n  const data = await r.json();\n  console.log(data);\n}\n```\n\nCon questa sintassi le chiamate asincrone possono essere eseguite in sequenza. Da notare che questa sintassi non\npermette comunque di bloccare un interno programma quando viene generata una promise, in quanto è limitata\nall'interno di una singola funzione.\n\nGli errori nelle funzioni esincrone possono essere gestire con le istruzioni `try` e `catch`.\n\n```javascript\nasync function fetchData() {\n  try {\n    const r = await fetch(\"https://jsonplaceholder.typicode.com/users/1\");\n    const data = await r.json();\n    console.log(data);\n  } catch (err) {\n    console.error(`Got and error: ${err}`);\n  }\n}\n```\n\nCome detto prima, le funzioni asincrone ritorneranno sempre una primise, e quindi possono essere usate all'interno del codice\ncon la sintassi vista prima:\n\n```javascript\nfetchData().then(() => console.log(\"Done!\"));\n```\n\nO, in alternativa, possono essere usati all'interno di un'altra funzione asincrona:\n\n```javascript\nconst g = async () => {\n  await fetchData();\n  console.log(\"done\");\n};\n```\n\nLa sezione [async and await](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await)\ndella documentazioen di JavaScript è un buon punto di partenza se si vuole approfondire.\n\n### Spread Operator\n\nLo _spread operator_ `...` permette di espandere un array of un oggetto ed estrapolarne i suoi elementi.\nÈ difficile spiegare come funziona lato teorico, ma viene molto facile capirlo partendo da degli esempio.\n\nSupponiamo di avere un array di numeri e volerne calcolare il minimo. JavaScript ci mette a disposizione\nla funzione `Math.min()` che calcola il minimo tra più numeri passati come argomenti. Purtroppo min non prende\nun array, ma una lista di numeri, quindi non possiamo passargli direttamente l'array.\n\n```javascript\nconst myArr = [1, 2, 3, 4];\nconst min = Math.min(myArr[0], myArr[1], myArr[2], myArr[3]);\n```\n\nGrazie allo spread operator, possiamo estrapolare i valori all'interno dell'array e passarli alla funzione `Math.min()` in questo modo:\n\n```javascript\nconst myArr = [1, 2, 3, 4];\nconst min = Math.min(...myArr); // 4\n```\n\nL'operator può anche essere usato per concatenare o creare nuovi array a partire da uno o più array esistenti:\n\n```javascript\nconst myArr = [1, 2, 3, 4];\nconst myArr2 = [0, 3, ...myArr, 10]; // [0, 3, 1, 2, 3, 4, 10]\n```\n\nO per copare un array velocemente:\n\n```javascript\nconst myCopy = [...myArr];\n```\n\nPossiamo usare lo spread operator anche per fare la stessa cosa sugli oggetti;\n\n```javascript\nconst myObj = { name: \"Ludovico\" };\nconst mySecondOby = { ...d, age: 33 }; // {name: 'Ludovico', age: 33}\nconst myCopy = { ...d }; // {name: 'Ludovico'}\n```\n\nUn'interessante funzionalità è che ci permette di copiare un oggetto e ridefinirne alcune proprietà, come in questo esempio:\n\n```javascript\nconst myObj = { name: \"Ludovico\", age: 32 };\nconst myCopy = { ...myObj, age: 33 }; // {name: 'Ludovico', age: 33}\n```\n\nIn questo caso, quando abbiamo collisioni sui nomi delle proprietà, il valore risolutate è ottenuto utilizzando l'ultima\noccorrenza della collisione (in questo caso `age:33` vince su `age:32` in quanto definito dopo).\n\nCome al solito vi consiglio di dare un'occhiata alla [documentazione ufficiale](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) per approfondire.\n\n### Proprietà di oggetti: scorciatoie\n\nIn modo simile agli spread operator, JavaScript ci mette a disposizione delle scorciatoie per definire velocemente\ndegli oggetti. Consideriamo ad esempio il seguente codice:\n\n```javascript\nconst name = \"Ludovico\";\nconst age = 33;\nconst user = { name: name, age: age }; // {name: 'Ludovico', age: 33}\n```\n\nIn questo caso, la ripetizione di `age` e `name` può essere omessa, come in questo caso:\n\n```javascript\nconst user = { name, age }; // {name: 'Ludovico', age: 33}\n```\n\nLe sue sintassi sono equivalenti e producono lo stesso risultato. In generale se vogliamo inserire all'interno di un oggetto\nuna proprietà che ha lo stesso nome e lo stesso valore di una variabile possiamo usare questa sintassi abbreviata.\n\nOvviamente, possiamo mixare le due sintassi, come in questo caso:\n\n```javascript\nconst user = { name, age, active: true }; // {name: 'Ludovico', age: 33, active: true}\n```\n\n### Destructuring\n\nIl _Destructuring_ è un'altra scorciatoia sintattica per creare variabili a partire dal contenuto di un oggetto o di un array\nin modo veloce, ed è un po' il contrario di quello visto su.\n\nAd esempio, supponiamo di avere una tupla (leggi array) e di voler prendere i primi due elementi e assegnarli a due variabile:\n\n```javascript\nconst myTuple = [33, \"Ludovico\"];\nconst age = myTuple[0];\nconst name = myTuple[1];\n```\n\nPossiamo abbreviare questa sintassi in questo modo:\n\n```javascript\nconst [age, name] = myTuple;\n```\n\nCosa succede se il numero di elementi dell'array è diverso da quello delle varibili che assegnamo? In caso abbiamo più variabili\na sinistra che elementi dell'array a destra, le variabili in più avranno valore `undefined`. In caso contrario, i valori dell'array\neccedenti vengono semplicemente ignorati.\n\nPossiamo anche combinare questa sintassi con lo _spread operator_:\n\n```javascript\nconst arr = [1, 2, 3, 4, 5];\nconst [a, b, ...c] = arr; // a = 1, b = 2, c = [3, 4, 5]\n```\n\nIn questo caso lo spread operator deve essere sempre l'ultimo elemento definito.\n\nLa stessa sintassi può essere usata per gli oggetti:\n\n```javascript\nconst user = { name: \"Ludovico\", age: 32 };\nconst { name, age } = user;\n```\n\nQuesta sintassi non deve necessariamente essere usata solo nell'assegnazione diretta, ma anche all'interno degli argomenti di funzione.\nAd esempio, possiamo semplificare questo codice:\n\n```javascript\nfunction f(user) {\n  console.log(user.name, user.age);\n}\n\nconst user = { name: \"susan\", active: true, age: 20 };\nf(user);\n```\n\nIn questo modo:\n\n```javascript\nfunction f({ name, age }) {\n  console.log(name, age);\n}\n\nconst user = { name: \"susan\", active: true, age: 20 };\nf(user);\n```\n\nIn questo caso, la funzione `f()` accetta un oggetto come argomento, ma invece di prenderlo interamente,\nprende solo le sue proprietà `name` e `age` scartando il resto.\n\nCome nel caso degli array, se le proprietà che vogliamo estrapolare non è definita gli viene assegnato il valore `undefined`.\n\nPotete approfondire questa sintassi in [questo articolo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) della documentazione.\n\n### Classi\n\nRispetto ai moderni linguaggi di programmazione, JavaScript non prevedeva il contetto di classe fino alla versione _ES6_.\nNon useremo molto le classi in JavaScript in generale, ma mi sembrava un'omissione troppo importante non accennarne nemmeno.\n\nEcco un esempio di cose si possono definire le classi in JavaScript:\n\n```javascript\nclass User {\n  // constructor (chiamato con `new User()`)\n  constructor(name, age, active) {\n    this.name = name;\n    this.age = age;\n    this.active = active;\n  }\n\n  // standard method\n  isActive() {\n    return this.active;\n  }\n\n  // async method\n  async read() {\n    const r = await fetch(`https://example.org/user/${this.name}`);\n    const data = await r.json();\n    return data;\n  }\n}\n\nconst user = new User(\"Ludovico\", 33, true);\n```\n\nPer saperne di più, vi rimando alla documentazione ufficiale di JavaScript: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).\n\n## Estensioni di JavaScript: JSX e Typescript\n\nFino ad adesso abbiamo parlato di feature all'interno del linguaggio JavaScript, quello che in gergo viene chiamato _Vanilla Javascript_.\nIn questa e nella prossima sezione, invece, approfondiremo delle features che non fanno parte dello standard ECMAScript, e nemmeno\nsono pensate per esserle.\n\nIn entrambi i casi si parla di estensioni non standard del linguaggio, che possono essere usate solo tramite appositi _transpiler_ e che\nprobabilmente non verranno mai nativamente integrati nei browser e negli interpreti ufficiali: stiamo parlando di _JSX_ e _TypeScript_.\n\n### JSX\n\n[JSX](https://facebook.github.io/jsx/) sta per _JavaScript XML_, è un linguaggio ideato da Facebook ed alla base di _React_\nper rendere più semplice ed immediato la creazione di contenuto inline nel codice JavaScript, pensato specialmente\nper integrare HTML dentro i nostri programmi.\n\nPer esempio, se vogliamo creare un paragrafo HTML (`<p>`) in Vanilla JavaScript, possiamo usare le DOM API per fare una cosa\ndel genere:\n\n```javascript\nconst paragraph = document.createElement(\"p\");\nparagraph.innerText = \"Hello, world!\";\n```\n\nOvviamente, il codice diventa molto complesso se vogliamo genstire interi documenti HTML.\n\nIn JSX, invece, possiamo usare un linguaggio ibrido tra Vanilla JavaScript e HTML:\n\n```jsx\nconst paragraph = <p>Hello, world!</p>;\n```\n\nChe come vedete è molto più semplice e conciso.\n\nEcco un esempio di JSX più complesso:\n\n```jsx\nconst myTable = (\n  <table>\n    <tr>\n      <th>Name</th>\n      <th>Age</th>\n    </tr>\n    <tr>\n      <td>Ludovico</td>\n      <td>33</td>\n    </tr>\n    <tr>\n      <td>Silvia</td>\n      <td>20</td>\n    </tr>\n  </table>\n);\n```\n\nChe può anche essere migliorato usando un array e la funzione `map()`:\n\n```jsx\nconst users = [\n  {\n    name: \"Ludovico\",\n    age: 33,\n  },\n  {\n    name: \"Silvia\",\n    age: 20,\n  },\n];\nconst myTable = (\n  <table>\n    <tr>\n      <th>Name</th>\n      <th>Age</th>\n    </tr>\n    {users.map((user) => (\n      <tr>\n        <td>{user.name}</td>\n        <td>{user.age}</td>\n      </tr>\n    ))}\n  </table>\n);\n```\n\nJSX è una componente chiave di React (e quindi di NextJS). E avremmo modo di approfondirlo all'interno dei prossimi capitoli.\n\n### TypeScript\n\nCome JSX, anche TypeScript è un'estensione di JavaScript, o meglio un _superset_ del linguaggio JavaScript inventato da\nMicrosoft per migliorare la produttività degli sviluppatori.\n\nJavaScript è un linguaggio di programmazione senza tipi, cioè all'interno di una stessa variabile possiamo inserire\ndiversi tipi di dati, come numeri, array, stringhe o interi oggetti.\n\nIn JavaScript, un codice di questo tipo è valido:\n\n```javascript\nlet myNum = 2;\n\nmyNum = \"hello\";\n```\n\nIl problema principale è che questo tipo di funzionalità porta alla generazione di codice non matenibile e diventa\nproblematico in progetti che crescono. Un altro problema di JavaScript è dovuto al fatto che la mancanza di tipi rende\nmolto più difficile documentare il codice. Ad esempio, se abbiamo una funzione di questo tipo:\n\n```javascript\nfunction f(a, b) {\n  // codice\n}\n```\n\nDobbiamo leggere il codice per capire:\n\n1. Che tipi di dati devono essere `a` e `b`;\n2. Che tipo di dati la funzione torna (o anche se ha o no un valore di ritorno);\n\nIn generale è possibile estrapolare dal contesto (o tramite commenti) questo informazioni. Ma a lungo andare gli sviluppatori\nperdono molto più tempo a ricordarsi o cercare di capire queste informazioni piuttosto che scrivere del codice.\n\nL'idea di TypeScript è quella di creare un linguaggio che estende le funzionalità di JavaScript limitando quello che può fare\nlo sviluppatore ma rendendo il processo di sviluppo del software più robusto, semplice ed autodocumentato. Lo fa introducendo i\ntipi nel linaggio (o meglio le _type annotation_ alle variabili, che permettono di specificare il tipo di una variabile), insieme\nad una serie di tool e analizzatori in fase di sviluppo che aiutano il programmatore a sviluppare.\n\nAd esempio, in TypeScript, la funzione precedente può essere scritta cosi:\n\n```ts\nfunction f(a: number, b: number): number {\n  // codice\n}\n```\n\nIn questo caso, lo sviluppatore vede subito che `a` e `b` sono dei numeri e che la funzione ritorna un numero. Inoltre,\nse provassimo a chiamare la funzione in questo modo:\n\n```ts\nf(\"ciao\", 45);\n```\n\nRiceveremmo immediatamente un errore di sintassi che ci avverte di un problema. In JavaScript avremmo dovuto eseguire il\nprogramma per evitarlo.\n\nTypeScript introduce tantissime features interessanti sul linguaggio, che velocizzano tantissimo il processo di sviluppo.\nIl linguaggio è diventato tanto popolare che ormai la maggiorparte dei progetti JavaScript sono in realtà sviluppati in\nTypeScript, e la popolarità è talmente alta nella community che si sta iniziando a parlare di introdurre alcune funzionalità\ndi TypeScript nel linguaggio principale.\n\nSebbene non siamo obbligati ad usare TypeScript in Next e ReactJS, entrabi i progetti sono fortemente integrati\ncon TypeScript ed il consiglio generare è di usare TypeScript dal primo momento. Per questo motivo ho deciso di\nsviluppare interamente questo tutorial in TypeScript, e avremmo tempo di approfondire il linguaggio nel corso\ndei prossimi capitoli.\n\n### TypeScript + JSX = TSX\n\nOvviamente, entrambi le estenzioni possono essere usate insieme, in questo caso si parla di _TSX_. Eccone un esempio:\n\n```jsx\ninterface User {\n  name: string;\n  age: number;\n}\n\nconst users: User[] = [\n  {\n    name: \"Ludovico\",\n    age: 33,\n  },\n  {\n    name: \"Silvia\",\n    age: 20,\n  },\n];\n\nconst myTable = (\n  <table>\n    <tr>\n      <th>Name</th>\n      <th>Age</th>\n    </tr>\n    {users.map((user) => (\n      <tr>\n        <td>{user.name}</td>\n        <td>{user.age}</td>\n      </tr>\n    ))}\n  </table>\n);\n```\n\n## Cosa abbiamo imparato?\n\nIn questo capitolo abbiamo visto insieme alcune funzionalità di JavaScript insieme a due estensioni del linguaggio: JSX e TypeScript.\nIl prossimo capitolo sarà dedicato alla creazione del primo progetto NextJS.\n",
          "slug": "javascript-moderno",
          "frontMatter": {
            "title": "Javascript Moderno",
            "readTime": 23,
            "imagePath": "/courses/nextjs-megatutorial/00001-javascript-moderno",
            "description": "JavaScript è in continua evoluzione, facciamo una breve carrellata delle feature di JavaScript moderno che andremo ad utilizzare in questo corso!",
            "published": true
          }
        },
        {
          "file": "/Users/ludovicorusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/00002-primi-passi-nextjs/index.mdx",
          "content": "\nAbbiamo parlato in questa guida di React e NextJS. Prima di iniziare la parte cicciosa di questo tutorial,\ncerchiamo di capire meglio esattamente a cosa ci riferiamo.\n\nReactJS è una libreria sviluppata da Facebook per lo sviluppo di Interfaccia Grafica (UI) nelle applicazioni Web.\nA differenza di altri progetti a cui spesso è affiancato (come Angular o VueJS), React è una semplice libreria, nel\nsenso che mette a disposizione una serie di blocchi (funzioni, classi eccetera) allo sviluppatore ma non\nforsa (come nel caso dei framework) ad adottare una specifica architettura o organizzazione del codice. Inoltre, a differenza\ndi altri framwork, ReactJS non integra soluzioni a problemi noti nello sviluppo di applicazioni Web, come ad esempio\nla gestione del Routing (i cambi della pagina) o l'integrazioni come Api esterne: in questi casi gli sviluppatori sono\nliberi di integrare librerie nell'ecosistema React che preferiscono per risolvere i loro problemi come meglio credono.\n\nQuesto ha dato parecchi vantaggi negli anni a ReactJS, in quanto ha permesso all'ecossitema creatosi intorno alla libreria\ndi evolvere in modi diversi, senza limitazioni imposte dal team di sviluppo originale. In particolare, intorno a React sono\niniziati a nascere i cosidetti \"MetaFramework\", cioè progetti che estendevano la libreria originale imponendo scelte\narchitetturali alla creazione di un progetto. La cosa interessante, a mio avviso, è che molti di questi framework non\nsono rimasti relegati a pure applicazioni frontend (come nel caso di Angular), ma sono stati realizzati in modo da poter\npermettere la creazione di siti completi, integrando anche tecnologie backend.\n\nTra questi metaframework, i più rilevanti (almeno per il mio percorso) sono stati [Gatsby](https://www.gatsbyjs.com/) e [NextJS](https://nextjs.org/).\n\n**Gatsby** è stato uno dei primi framework ReactJS a permettere la creazione di siti statici (o prerenderizzati).\nEntreremo in futuro in questa guida nel dettaglio di cosa vuol dire prerendering, ma in generale quello che fa Gatsby è\ndare la possibilità allo sviluppatore di creare un sito in ReactJS composto da divere pagine, e (in fase di build), renderizzare\nl'intero progetto in modo da permettere di essere servito senza la necessità di avere un server web completo. Quest'idea, qualche anno fa,\nandava molto di moda in quanto permetteva agli sviluppatori di creare siti web completi con costi di hosting quasi (o completamente) nulli.\n\n**NextJS**, invece, porta l'idea di GatsbyJS al suo massimo, in quanto permette, all'intero di uno stesso framework, di controllare\npagina per pagina se effettuare il rendering lato frontend, lato backend, o entrambi. Con NextJS abbiamo il massimo della\nflessibilità nella creazione di siti web complessi, in quanto possiamo decidere in modo semplice e con delle API molto facili di utilizzare,\ncome una pagina deve essere renderizzata. Una pagina che contiene contenuti statici (come un blog post o un documento) può essere\nrenderizzata a buildtime ed avere un'inpatto minimo in termini di latenza e risorse per essere servita al cliente. Dall'altra parte\npagine che richiedono contenuti molto variabili possono essere renderizzate nel backend nel momento in cui viene fatta la richiesta\ndal cliente, come i classici siti web.\n\nQuesta capacità ha reso NextJS un progetto molto popolare nel modo JavaScript, che negli ultimi anni ha preso il sopravvento ed\nè sicuramente uno dei framework consigliati per realizzare siti web di tutti i tipi, dal blog personale a grandi siti aziendali.\n\n## Creazione del primo progetto NextJS\n\nPer poter utilizzare NextJS abbiamo bisogno di aver installato _node_ sul nostro terminale.\nQueta operazione è molto semplice, ed in generale consiglio di seguire la [guida del sito ufficila di Node](https://nodejs.org/en/).\n\nPer i più smanettoni, ed in particolare per chi vuole avere la possibilità di controllare puntualmente la versione di nodejs sul proprio\ncomputer, suggerisco di dare un'occhiata al progetto [NVM (Node Version Manager)](https://github.com/nvm-sh/nvm), che ci permette\ndi installare ed eseguire versioni diverse di node in modo semplice ed immediato.\n\nIn questo e nei prossimi passi, userò la versione di node _v16_, che al momento risulta essere la versione LTS (quella con supporto maggiore\nper interderci). Ad ogni modo, non dovrebbero esserci troppi problemi nell'utilizzare una versione di node successiva.\n\nUna volta installato node, per verificare che tutto funzioni correttamente, possiamo digiare il comando all'interno del terminale\n\n```bash\n$ node -v\nOutput: v16.14.0\n```\n\nche ci dirà quale versione di node abbiamo sul nostro sistema.\n\nPer creare un nuovo progetto, NextJS ci mette a disposizione il comando `create-next-app` che inizializzerà un progetto\nblueprint funzionante. Noi lo chiamere con l'opzione `--typescript`, per avere automaticamente installato il supporto a TypeScript.\n\n```bash\n$ npx create-next-app@latest --typescript\nNeed to install the following packages:\n  create-next-app@latest\nOk to proceed? (y) y\n✔ What is your project named? … my-first-site\nCreating a new Next.js app in /Users/ludusrusso/develop/next-js-megatutorial/my-first-site.\n\nUsing yarn.\n\nInstalling dependencies:\n- react\n- react-dom\n- next\n\n# ...\n```\n\nIl promt del tool ci chiederà alcune informazioni, intanto se vogliamo installare l'ultima versione del pacchetto `create-next-app`,\na coi ovviamente dovremmo rispondere di sì (digitando `y`). Inoltre ci chiederà che nome dare al progetto che stiamo creando.\nScegliete il nome che preferite (io ho scelto `my-first-site`), premete invio e attendete che l'installazione sia completata.\n\nVogliamo vedere se il sito funziona? Ci basta entrare nel progetto `cd my-first-site` e lanciare il server con il comando `npm run dev`.\n\n```bash\n$ npm run dev\n\n> my-first-site@0.1.0 dev\n> next dev\n\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\nwait  - compiling...\nevent - compiled client and server successfully in 805 ms (125 modules)\n```\n\nA questo punto, apriamo il nostro browser preferito (io userò Chrome) e digitiamo l'indirizzo che vediamo\nnel prompt: `http://localhost:3000` per vedere il sito.\n\n![Primo sito web](./first-site.png)\n\nCome potete vedere, abbiamo appena eseguito il nostro sito web, che si presenta\ncome una pagina HTML base con rimandi alla documentazione e ai tutorial di NextJS.\n\nPer spegnere il server, ci basterà digirare sul terminale la combinazione `ctrl-C`.\n\n### Anatomia di un progetto NextJS\n\nPrima di iniziare a scrivere codice, credo sia importante iniziare ad esplorare\nil progetto per capire come è composto. Avremmo tempo di capire bene come\nmuoverci per bene tra i file di un progetto Next, ma credo sia importante\niniziare a riconoscere alcune cose fin dall'inizio.\n\nSe non lo avete già fatto, aprite il progetto con il vostro editor di testo.\nCome ho detto io userò in questa guida [VSCode](https://code.visualstudio.com/), che consiglio\ncaldamente a tutti voi in quanto è molto ben integrato con il mondo JavaScript e React. Inoltre,\nvi farò vedere più avanti alcuni tool ed estenzioni molto utili per\nvelocizzare lo sviluppo basati proprio su VSCode.\n\n> Se avete installato il [command line tool di VSCode](https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line), potete aprire VSCode nella cartella corrente semplicemente digitando `code .` all'interno della cartella del vostro progetto.\n\nIl progetto dentro VSCode dovrebbe apparirvi in questo modo:\n\n![VSCode](./vscode-project.png)\n\nNon ci addentremo in tutti i file del progetto, ma vediamo insieme i più importanti.\n\n#### Il file `README.md`\n\nTutti i progetti che si rispettano hanno un file di documentazione che\ninforma e ricorda agli sviluppatori come gestire il programma. NextJS ci prepara\nun template di questo file con dei comandi base di come iniziare ad usare il progetto\nNextJS.\n\nÈ buona prassi aggiungere qualcosa a questo file in modo da rendere più chiaro\na cosa si riferisce il progetto. Potete scriverci quello che volete, per il momento\nio aggiungo queste poche righe all'inizio del file di documentazione:\n\n```md\n## Pair repo for NextJS Mega Tutorial\n\nQuesta è una semplice applicazione implementata con NextJS e contiene il progetto\nNextJS sviluppato durante il corso.\n```\n\n#### Il file `package.json`\n\nIl file `package.json` è il principale file di ogni progetto node, all'interno\ndel file troviamo le definizioni delle dipende del nostro progetto, alcuni\nscript che vogliamo eseguire ed informazioni utilizi sul progetto.\n\nDalla sezione `dependencies` vediamo che il nostro progetto si porta dietro\nsolo 3 dipendenze: `next`, `react` e `react-dom`.\n\n```json\n{\n  ...\n  \"dependencies\": {\n    \"next\": \"12.1.6\",\n    \"react\": \"18.1.0\",\n    \"react-dom\": \"18.1.0\"\n  }\n}\n```\n\nNon c'è molto da dire di queste dipendenze, se non, cosa che sapeva già, che\nil progetto che abbiamo creato è un progetto NextJS e React.\n\nIn particolare `react` e `react-dom` sono alla base di ogni progetto React,\nin quanto contengono, rispettivamente, la libreria princiapale e la parte\nche permette alla libreria di agire sul Documento HTML (DOM). Come vedete stiamo\nusando la versione di react 18, che è l'ultima versione rilasciata nel momento\nin cui scrivo.\n\nLa dipendenza `next` invece include tutte le funzionalità di `NextJS`. Anche in\nquesto caso stiamo usando la verisone `12`, l'ultima major release rilasciata\nnel momento in cui scrivo questo articolo.\n\nSpostandoci nella sezione _scripts_, vediamo che nextjs ci prepara degli\nscript di default per agire sulla nostra applicazione.\n\n```json\n{\n  ...\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  }\n}\n```\n\nGli scirpt possono essere eseguiti con il comando `npm run <nome-script>`, e\ncome immagino molti di voi avranno capito, quando prima abbiamo eseguito il comando\n`npm run dev` stavamo lanciando lo script `dev` di questa sezione.\n\nPer ora ci interesserà principalmente lo script `dev`, che ha appunto lo scopo\ndi lanciare il server next in modalità di sviluppo. `build` ci permette\ninvece di _buildare_ l'applicazione e prepararla per essere eseguita in produzione,\nmentre `start` ci permette di _avviare_ l'applicazione precedentemente buildata. Questi\ndue scirpt ci serviranno nei prossimi capitoli quando ci occuperemo di rilasciare\nil nostro sito web in produzione.\n\nPer finire, il comando `lint` ci permette di lanciare il linter del codice, che\nverificherà che non ci siano problemi o warning a livello di sintassi JavaScript.\nIn generale la fase di lint viene eseguita prima di ogni build, quindi non useremo\nmolto questo comando.\n\nPer finire, nella sezione `devDependencies` troviamo tutte le dipendenze che sono\nutili al progetto in fase di sviluppo ma che non servono per la produzione.\n\n```json\n{\n  \"devDependencies\": {\n    \"@types/node\": \"17.0.32\",\n    \"@types/react\": \"18.0.9\",\n    \"@types/react-dom\": \"18.0.3\",\n    \"eslint\": \"8.15.0\",\n    \"eslint-config-next\": \"12.1.6\",\n    \"typescript\": \"4.6.4\"\n  },\n  ...\n}\n```\n\nPartiamo da `typescript`, che è la libreria che ci permette di usare ed interpretare\nil codice in linguaggio typescript. Come abbiamo visto nei capito precedenti, TypeScript\nnon è un linguaggio che viene interpretato nativamente dal Browser o in generale dagli interpreti\nJavaScript. Per questo motivo lo troviamo tra le dipendenze di dev. Una volta buildato il progetto\nsemplicemente tutto il codice Typescript sparisce e viene _transpilato_ in puro JavaScript.\n\nTutte le dipendenze che iniziano con `@types` sono necessarie per\navere le definizioni `typescript` di librerie implementate in JavaScript puro. Sono essenzialemnte\nun'aggiunta alla libreria principale in modo da far sapere al nostro editor di testo quali sono i\ntipi e le funzionalità TypeScript della libreria originale. Non è importante per noi sapere esattamente\nil funzionamento, vi basti sapere che è prassi, per molte librerie, definire i tipi TypeScript in una libreria\nseparata. Ne incotreremo alcune nei prossimi capitoli.\n\nPer finire, le due dipendenze `eslint` e `eslint-config-next` riguandano il linter (quindi l'analizzatore del codice),\nche ovviamente ci serve solo in fase di sviluppo e non è necessaria quando facciamo il deploy in produzione.\n\n> È compito dello sviluppatore sapere quali dipendenze vanno installate come `devDependencies` e quali come `dependencies`. Molti sviluppatori, poco attenti o poco esperti, tendono ad installare tutto all'interno della sezione `dependencies`. Sebbene questo non comporti un grosso problema nel funzionamento del progetto, diventa sicuramente un problema di ottimizzazione in quanto il pacchetto finale che andrà in produzione sarà molto più pensante del necessario.\n\n#### `npm` VS `yarn`\n\nLe dipendenze in un progetto node si gestiscono attraverso dei programmi\nchiamati _package manager_. Il package manager ufficiale di node è `npm`\n(che sta appunto per _node package manager_). Questo package manager ha avuto\nstoricamente alcuni problemi di funzionamento, tanto da costringere la community\na sviluppare package manager alternativi per risolvere questi problemi. `yarn`, sviluppato\nda facebook, è uno dei package manager alternativi più comuni nel mondo node, ed in\nparticolare molto usato nel mondo React.\n\nPer questo motivo, se vi addentrerete nel mondo dello sviluppo software JavaScript,\ntroverete spesso l'utilizzo quasi indistinto delle due tecnologie, `npm` e `yarn`.\nNel loro utilizzo cambia di fatto veramente poco, ma in generale ormai da qualche anno\nla differenza tra i due progetti è praticamente inesistente.\n\nPotete usare a piacere `npm` o `yarn`, di fatto (se non in alcuni comandi) non ho mai trovato\nrealmente delle differenze tra i due. Per mia scelta, in questo progetto, userò solamente\nil comando `npm`. Un po' per semplificare le cose (richiede una dipendenza in meno dato che il comando\nnpm è automaticamente installato con node), un po' perchè tra le due è sempre stato il mio\ncomando di default.\n\nDetto questo, cosa cambia nel pratico? NextJS usa yarn di default, ve ne accorgenete perchè\ntrovate il file `yarn.lock` all'interno del progetto. Per passare a `npm` è sufficiente\ncancellare il file e difitare il comando `npm install`.\n\n```bash\n$ npm install\n\nchanged 1 package, and audited 230 packages in 1s\n\n68 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n```\n\nVedrete che apparirà un nuovo file `package-lock.json` che è l'equivalente npm i `yarn.lock`.\nQuesti file rappresentano uno screenshot delle dipendenze che abbiamo installato (comprese quelle indiritte, cioè dipendenze delle dipendenze),\ne permettono al sistema di ricostruire in futuro esattamente l'attuale installazione anche su altri computer o sistemi diversi.\n\nPiccola nota, uno dei principali problemi di giovinezza di `npm` era l'assenza di questo file che rendeva il porting di progetti tra diversi\nsistemi instabile.\n\nIl file `package-lock.json` non deve mai essere modificato da uno sviluppatore, è automaticamente gestito dal package manager, quindi non\nè importante vedere cosa troviamo al suo interno. Sappiate solo che esiste.\n\n#### Typescript\n\nAbbiamo inizializzato il nostro progetto con Typescript, e questa cosa\nsi porta dietro due cose importnati su cui voglio puntare la vostra attenzione.\n\nIntanto troviamo un file `tscondig.json` che è il file di configurazione per Typescript.\nIn particolare questo file contiene alcune informazioni per dire a Typescript come\ncomportarsi. Per il momento non è importante il suo contenuto, ma lo andremo ad\nesplorare in futuro.\n\nLa seconda, è che i file che andremo ad implementare hanno estenzione `.ts` o `.tsx`.\nCome ad esempio, rispettivamente, i file `pages/api/hello.ts` e `pages/index.tsx`.\n\nI file `.ts` i file nativi _typescript_, mentre quelli `.tsx` contengono codice TypeScript\nscritti in JSX (ricordate? TypeScript + JSX = TSX). All'interno di questi file, infatti, troverete\nun misto tra TypeScript e HTML.\n\n#### Pagine ed API\n\nL'ultima cosa su cui voglio soffermarmi, prima di andare ad implementare finalmente del codice, è\nla cartella `pages` che trovate nel progetto.\n\nCome abbiamo detto NextJS è un framework (o metaframework dato che è basato su ReactJS), quindi non solo\noffre una serie di funzionalità ma impone allo sviluppatore un modo di organizzare il codice.\n\nLa cartella `pages` è una cartella importante in NextJS, in quanto qualsiasi cosa metteremo qui dientro (a parte alcune eccezioni che vedremo)\ndiventa automaticamente una pagina HTML del nostro progetto. Il file `pages/index.tsx` sarà tramutato nel file `index.html` del nostro sito,\ncioè la pagina inziale che sarà raggiunta tramite `https://<dominio>.<com>/`. Se volessimo fare una pagina chiamata `/about`, ci basterà\ncreare un file `pages/about.tsx`. Anche il contenuto di questi file deve essere implementato in un certo modo. In particolare, come vedremo nella sezione\nsuccessiva, il componente React che implementa la pagina deve essere esportato con `export default`.\n\nIl file `pages/_app.tsx` è una delle eccezioni che dicevo prima, in questo file troviamo il componente `App` che _wrappa_ tutte le nostre pagine. Anche\nin questo caso, per ora non dobbiamo preoccuparci troppo del funzionamento perchè lo esploreremo per bene in seguito. Giusto per completezza, NextJS\nprevede altri due file che non verranno gestiti come pagine, che sono `_document.tsx` e `_middleware.ts`. Scopriremo il comportamento di questi file in futuro.\n\nInfine, degno di nota è la cartella `pages/api`. Tutto i file contenuti in questa cartella non verranno gestiti come pagine, ma come _api endopoint_. Questi\nfile saranno sempre eseguiti dal backend (quindi non sono pagine frontend o generate staticamente) ed il loro risultato non sarò necessariamente\nuna pagina HTML ma dei dati (solitamente ritornati in formato JSON). Un esempio classico dell'utilizzo di queste API è quello di permettere agli utenti\ndi effettuare un'autenticazione e ricevere dati personalizzati. Ma anche in questo caso avremmo tempo per approfondire andando avanti in questo progetto.\n\n### Customizziamo la nostra pagina\n\nDopo la parte introduttiva, siamo finalmente pronti per esplorare il codice e iniziare a modificarlo. Iniziamo\nquindi a vedere come customizzare il nostro sito.\n\nAbbiamo visto che la pagina principale del sito è gestita nel file `pages/index.tsx`. Vediamo cosa ci sta dentro:\n\nDalla sezione di import\n\n```tsx\nimport type { NextPage } from \"next\";\nimport Head from \"next/head\";\nimport Image from \"next/image\";\nimport styles from \"../styles/Home.module.css\";\n```\n\nvediamo che il progetto importa due componenti da NextJS (li approfondiremo in seguito), un file di stili CSS\n(cosa che a me non piace molto e in futuro eviteremo di importare il CSS in questo modo). Vediamo infine subito una\nsintessi nuova che non abbiamo approfondito: `import type`.\n\nQuesta è una sintassi specifica di TypeScript (quindi non di JavaScript) che ci permette di importare un oggetto solo\nper utilizzarne la definizione dei tipi. In realtà ogni riga `import type` viene semplicemente cancellata in JavaScript,\nè serve al progetto TypeScript per identificare una definizione tramite type annotation.\n\nVediamo subito, infatti, che l'oggetto `NextPage` viene usato per definire una pagina NextJS, come mostrato qui:\n\n```tsx\nconst Home: NextPage = () => {\n  /// ....\n};\n\nexport default Home;\n```\n\nL'oggeto Home è la nostra pagina NextJS, e ce ne accorgiamo perchè viene esportato con `export default` alla fine del documento.\nVi ricordo, infatti, che in NextJS l'oggetto che viene esportato di default all'interno di un file dentro la cartella `pages` è quello\nche poi viene renderizzato come pagina.\n\n`Home` è un componente funzionale React, cioè il modo consgliato in react per definire un componente da renderizzare. In particolare\nun componente funzionale è una funzione il cui valore di ritorno è un oggetto JSX.\n\nVedimao infatti che quello che torna questa funzione è un `<div>` html con dentro alcune cose.\n\nSe proviamo a modificare l'html di questo componente, vedremo immediatamente una modificare nella pagina renderizzata.\n\nAd esempio, fare questo cambiamento:\n\n```diff\n<h1 className={styles.title}>\n  - Welcome to <a href=\"https://nextjs.org\">Next.js!</a>\n  + Questo è il mio primo progetto\n</h1>\n```\n\nLanciando il progetto con `npm run dev` vedremo a nel browser\nla nuova pagina modificata.\n\n![First Site 2](./first-site2.png)\n\n## Setup di una Repository GitHub\n\nSviluppare non vuol dire soltando saper usare un linguaggio\ndi programmazione, ma anche saper usare una serie di strumenti\nche ci permettono di gestire un progetto.\n\nTra questi, sicuramente [git](https://git-scm.com/) è tra i più essenziali,\nin quanto è così tanto integrato all'interno dei tool di sviluppo\nche ormai uno sviluppatore professionale che non sa usare git è\nun'assurdità. Per questo motivo git sarà alla base di tutti i progetti\nche svilupperemo all'interno di questa serie, e per ogni progetto\nche andremo a sviluppare ci sarà un'equivalente repository git\nper gestire l'evoluzione del codice.\n\nMi aspetto quindi che, se segui questa guita, ti occuperai non soltando\ndi sviluppare del codice ma anche di gestirlo e deployarlo tramite\ngit su GitHub, cosa che faremo insieme alla fine di ogni capitilo in cui\nscriveremo del codice.\n\nInoltre, con l'avvento della fisolofia _devops_ e _gitops_, git e github diventeranno\nanche strumenti essenziali per deployare il nostro codice e rendere il sito\ndisponibile su internet. In uno dei prossimi capitoli vedremo come fare, per il momento\noccupiamoci di creare una repository github dove deployare il progetto.\n\nPer prima cosa dobbiamo creare un account su GitHub se non lo abbiamo già.\nA questo punto, possiamo creare una repository all'interno del nostro account, nel\nmio caso si chiama `ludusrusso/next-js-megatutorial`.\n\n![Creazione Repo GitHub](./creazione-repo-github.png)\n\nDa notare che il comando `create-next-app` ci ha già creato un progetto\ngit sul nostro terminale, quindi non dobbiamo inizializzare git ma solo aggiungere\ne committare le modifiche fatte:\n\n```bash\n$ git add .\n$ git commit -am \"feat: update index.tsx\"\n```\n\nPer finire, possiamo deployare il nostro progetto sulla repository.\nAddiungiamo la nuova origin git al progetto con il comando e pushamo il progetto\nonline.\n\n```bash\n$ git remote add origin git@github.com:<nome del repo>.git\n$ git push origin main\n```\n\n## Cosa abbiamo imparato?\n\n- Cosa sono NextJS e ReactJS;\n- Come creare un nuovo progetto NextJS;\n- Come muoverci all'interno di un progetto NextJS;\n- Come customizzare un componente React;\n\n[Qui](https://github.com/ludusrusso/next-js-megatutorial/tree/c1) trovate lo stato\ndel mio progetto alla fine di questo capitolo.\n\nNel prossimo capitoli inizieremo ad utilizzare i componenti React e creeremo la nostra prima\npagina NextJS da zero.\n",
          "slug": "primi-passi-con-nextjs",
          "frontMatter": {
            "title": "Primi passi con NextJS",
            "readTime": 16,
            "imagePath": "/courses/nextjs-megatutorial/00002-primi-passi-nextjs",
            "description": "Iniziamo a usare React e NextJS creando un semplice progetto",
            "published": true
          }
        },
        {
          "file": "/Users/ludovicorusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/00003-react-components/index.mdx",
          "content": "\nIl cuore di ogni progetto NextJS è React, ed il cuore di ogni progetto React sono i _React Components_.\nPer capire meglio come muoverci all'interno dello sviluppo di un sito NextJS (o comunque di un'app React in generale)\ndobbiamo sapere come funzionano e come possiamo usare i _React Compoents_. Questo capito è dedicato\na questo.\n\nL'idea di _React_ è semplice. Invece di scrivere il nostro codice HTML interamente come un unico documento, possiamo\ndividerlo in semplici componenti (i component appunto) che possono poi essere composti per\ncreare la nostra applicazione finale. In generale un component in React è una parte di UI (con le sue interazioni)\nche può essere creato a partire da altri componenti (creati da noi o componenti HTML base come `<div>` e `<p>`).\n\nReact permette di definire un component in due modi. Utilizzando un **Class Component** (che modella il component)\ncome una classe, o utilizzando un **Fuctional Component**, che lo modella come una funzione.\n\nI Class Component sono il modo originale che React usava per modellare i componenti. Attualmente il loro utilizzo è molto\nlimitato in quanto **Fuctional Component** sono molto più semplici da implementare ed utilizzare. In questa serie\nuseremo solamente i functional component.\n\nPer definire un component, quindi, basta creare una funzione che ritorna del codice `HTML` o meglio `jsx`, come in questo caso:\n\n```tsx\nconst MyComponent = () => {\n  return <h1> Ciao </h1>;\n};\n```\n\nPossiamo poi usare il nostro component da qualche altra parte in questo modo\n\n```tsx\n<MyComponent />\n```\n\nPossiamo chiamare un componente come vogliamo, ma React di mette un vincolo: deve iniziare con una lettera maiscuola.\n\nI component possono ricevere in ingresso un oggetto, chiamato `Props`, che contiene delle variabili\nche possono essere usate per renderizzare il componente stesso, ad esempio in questo modo:\n\n```tsx\ninterface MyComponentProps {\n  name: string;\n}\n\nconst MyComponent = ({ name }: MyComponentProps) => {\n  return <h1> Ciao, {name}! </h1>;\n};\n\n<MyComponent name=\"Ludovico\" />;\n// Render: <h1> Ciao, Ludovico! </h1>\n```\n\nIn questo caso abbiamo usato una interfaccia `typescript`, che è il modo in typescript per definire\nil tipo di un oggetto. Facendo così il compilatore ci informerà, anche in fase di rendering, che\ndobbiamo passare come props al component la variabile `name` che è di tipo stringa.\n\nLa definizione precedente può essere abbreviata come segue:\n\n```tsx\nconst MyComponent = ({ name }: { name: string }) => {\n  return <h1> Ciao, {name}! </h1>;\n};\n\n<MyComponent name=\"Ludovico\" />;\n// Render: <h1> Ciao, Ludovico! </h1>\n```\n\nMa per componenti con tante proprietà consiglio di usare il formato più esplicito, in quanto più semplice da leggere.\n\nIn react, i componenti possono avere una proprietà particolare chiamata children, che deve essere di tipo `ReactElement`.\nAll'interno della props `children` troveremo il contenuto `jsx` passato come figlio al componente in fase di utilizzo, come\nin questo esempio.\n\n```tsx\ninterface MyComponentProps {\n  name: string;\n  children: ReactElement;\n}\n\nconst MyComponent = ({ name, children }: MyComponentProps) => {\n  return (\n    <div>\n      <h1> Ciao, {name}! </h1>\n      <div> {children} </div>\n    </div>\n  );\n};\n\n<MyComponent name=\"Ludovico\">\n  <h2> Sono un componente figlio </h2>\n</MyComponent>;\n// Render:\n// <div>\n//   <h1> Ciao, Ludovico! </h1>\n//   <div> <h2> Sono un componente figlio </h2> </div>\n// </div>\n```\n\n## Iniziamo ad usare i components\n\nPer capire il funzionamento dei componenti e cosa possiamo farne, riprendiamo il nostro progetto\nNext ed iniziamo a svilupparne subito qualcuno.\n\nPer iniziare a lavorare, possiamo creare una nuova pagina bianca su cui fare un po' di esperimenti.\nIniamo quindi con un file vuoto chiamato `experiments.tsx` all'interno della cartella `pages/`.\n\nCreiamo un componente da cui partire all'interno di questa pagina, ed esportiamolo con `export default`\nin modo che NextJS sappia cosa renderizzare.\n\n```tsx\n// pages/experiments.tsx\nconst ExperimentsPage = () => {\n  return <div> Experiments Page </div>;\n};\n\nexport default ExperimentsPage;\n```\n\n> Potete dare al componente principale qualsiano nome preferite. In generale, il mio consiglio è usare il nome della pagina seguto da `Page`.\n\nLanciamo il server con il comando `npm run build` come visto nel capitolo precedente, e apriamo il browser sulla pagina\n`http://localhost:3000/experiments`:\n\n```bash\nnpm run dev\n\n> my-first-site@0.1.0 dev\n> next dev\n\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\nwait  - compiling...\nevent - compiled client and server successfully in 906 ms (125 modules)\n```\n\nDovremmo ottenere questo:\n\n![Experiments Page](./experiments.png)\n\nComplimenti, avete implementato il vostro primo componente e la vostra prima pagina NextJS.\n\n### Usare il live rendering di Next in modalità Dev!\n\nNextJS (ma in generale React e tutti i progetti Web moderni), mettono a disposizione un live server in\nmodalità dev che ascolta le modifiche nei file e automaticamente aggiorna la pagina nel browser che stiamo\nvisualizzando.\n\nLasciando il server acceso, infatti, se provate a cambiare qualcosa all'interno della pagina vi accorgerete che\nil browser automaticamente si rifresha per visualizzare le vostre modifiche. Una cosa molto comoda per avere\nun feedback loop veloce quando sviluppiamo.\n\n### Implementiamo ed usiamo un component React all'intenrno della pagina\n\nProviamo a sviluppare ed usare un componente. Ogni sito che si rispetti, solitamente,\nha un Nav e un Footer che vengono mostrati in ogni pagina, indipendentemente dal contenuto.\nÈ una buona occasione ed opportunità sfruttare react per astrarre questi due oggetti in\ndue component per poi poterli riutilizzare facilmente.\n\nCreiamo quindi all'interno dello stesso file (di solito si fa l'export default, i nostri component):\n\n```tsx\nconst Nav = () => {\n  return <nav>React Megaturial Navigation</nav>;\n};\n\nconst Footer = () => {\n  return <footer>React Megaturial; all right reserverd</footer>;\n};\n```\n\nChe possono essere usati all'interno della pagina principale:\n\n```tsx\n// pages/experiments.tsx\nconst ExperimentsPage = () => {\n  return (\n    <>\n      <Nav />\n      <div> Experiments Page </div>\n      <Footer />\n    </>\n  );\n};\n```\n\nChe genera il seguente risultato:\n\n![Nav e Footer](./nav-footer.png)\n\nIl sito è bruttino, lo so! Ma ci preoccuperemo in seguito di applicare un po' di stile CSS per renderlo accattivamente.\nPer ora accountentiamoci di scrivere solo HTML.\n\n### React Fragment\n\nAvete notato una cosa strana nel codice? Abbiamo wrappato la nostro pagina principale all'interno di\nun tag HTML vuoto `<></>`, che non è codice HTML valido.\n\nQuesto oggetto viene chiamato **React Fragment**, e semplicemente non viene renderizzato all'interno del nostro DOM.\nL'uso del fragment è un semplice escamotage dovuto al fatto che, in React e JSX, non possiamo ritornare una lista\ndi tag HTML da un componente. In altre parole, una sintassi come la seguente:\n\n```tsx\n// pages/experiments.tsx\nconst ExperimentsPage = () => {\n  return (\n    <Nav />\n    <div> Experiments Page </div>\n    <Footer />\n  );\n};\n```\n\nsemplicemente non è presta in JSX.\n\n![JSX error](./jsx-error.png)\n\nIn casi di questo tipo si usa il fragment per evitare questo errore.\n\n### Interazioni e stato di un componente con `useState`\n\nFin qui tutto bene, ma i componenti che abbiamo realizzato sono molto semplici e basilari. Come facciamo\na gestire un cambiamento di stato all'interno di un componente? In altre parole, come facciamo\na far si che il contenuto di un componente (e quindi la sua renderizzazione) cambia a comando?\n\nPer fare questo possiamo utilizzare una serie di strumenti che React ci mette a disposizione\nchiamata **Hooks**, che appunto ci servono per gestire lo stato del component e in generale il suo comportamento\ndurante il rendering. Ci sono tanti hooks che React ci mette a disposizione, quello che useremo adesso è uno dei più\ncomuni, e si chiama `useState`.\n\nQuello che vogliamo fare è aggiungere un bottone nel componente principale che ci permette di incrementare\nuna variabile, ed usare un secondo componente per visualizzare questo valore.\n\nPariamo dal componente figlio: questo deve avere una props `num:number` e visualizzare a video il valore di num:\n\n```tsx\nconst Visualizer = ({ num }: { num: number }) => {\n  return <span>Valore = {num}</span>;\n};\n```\n\nChe può essere usato in questo modo nel componente principale:\n\n```tsx\nconst ExperimentsPage = () => {\n  const value = 10;\n\n  return (\n    <>\n      <Nav />\n      <div> Experiments Page </div>\n      <div>\n        <Visualizer num={value} />\n      </div>\n      <div>\n        <Visualizer num={value + 10} />\n      </div>\n      <Footer />\n    </>\n  );\n};\n```\n\nCome potete vedere, stiamo renderizzando il componente in due modi, il primo passandogli il valore originale e\nil secondo passandogli un nuovo valore ottenuto sommando a quello originale 10.\n\n![Passaggio di Valore](./value.png)\n\nQuello che vogliamo fare però è rendere il nostro progetto dinamico. Per prima cosa,\ndobbiamo definire la nostra variabile `value` come stato interno al componente, usando la funzione `useState()`:\n\n```tsx\n+ import { useState } from \"react\";\n\nconst ExperimentsPage = () => {\n-  const value = 10;\n+  const [value] = useState(10);\n\n  return (\n    <>\n      <Nav />\n      <div> Experiments Page </div>\n      <div>\n        <Visualizer num={value} />\n      </div>\n      <div>\n        <Visualizer num={value + 10} />\n      </div>\n      <Footer />\n    </>\n  );\n};\n```\n\nQuesta modifica non cambierà nulla nella nostra parte grafica, ma informerà il componente che `value` è\nuno stato e il suo valore può cambiare nel tempo.\n\nLa riga che abbiamo modificato:\n\n```tsx\nconst [value] = useState(10);\n```\n\nfunziona in questo modo: React inizializza il nostro stato al valore che passiamo alla funzione, in questo caso\n10, e ritorna una tupla (cioè una specie di array i cui elementi sono di tipi diversi) di due elementi.\n\nIl primo elemento è la variabile che contiene il valore dello stato, e fin qui nulla di strano. Il secnodo elemento, invece,\nè una funzione che ci permette di settare un nuovo valore al nostro stato. Per estrapolare questa funzione\ndobbiamo usare questo:\n\n```tsx\nconst [value, setValue] = useState(10);\n```\n\n> Notare che stiamo usando l'unpacking degli array per prendere i valori che ci interessano.\n\n`setValue` è una funzione particolare, in quanto oltre a cambiare il valore di `value` forza anche il\ncomponente ad effettuare un rerendering. In questo modo sia il componente stesso che tutti i sottocomponenti\nche usano il nostro stato nelle props verranno rirenderizzati, e vedremo a video dei cambiamenti.\n\n`setValue` può essere usato in due modi. La prima è chiarla passando il nuovo valore che vogliamo dare al\nnostro stato, ad esempio:\n\n```jsx\nsetValue(20);\n```\n\nIl secondo modo è passare una funzione che, preso lo stato attuale come parametro, restituisce il nuovo stato,\nad esempio, se vogliamo incrementare il valore, possiamo fare così:\n\n```jsx\nsetValue((s) => s + 1);\n```\n\nDa notare che, avendo accesso alla variabile `value`, potremmo fare lo stessa cosa in questo modo:\n\n```jsx\nsetValue(value + 1);\n```\n\nSebbena questa sintassi funzioni ed sia molto usata rispetto a quella funzionale, il team di React la sconsiglia\nin quanto può portare a strani comportamenti in caso di chiamate contemporanee. In generale, preferisco usare quella\nfunzionale, sebbene ogni tanto mi \"scappi\" usare quest'ultima versione.\n\nPer usare `setValue` dobbiamo pensare a quelche tipo di interazione con il componente. E la cosa più semplice è\nmetterci dei bottoni:\n\n```jsx\n<div>\n  <button onClick={() => setValue((s) => s + 1)}>Increment</button>\n  <button onClick={() => setValue((s) => s - 1)}>Decremente</button>\n  <button onClick={() => setValue(0)}>Reset</button>\n</div>\n```\n\nChe ci permetteranno di incrementare, decrementare e resettare il valore di `value`:\n\n![setValue](./setvalue.png)\n\nAbbiamo introdotto in questo esempio anche l'utilizzo del tag `<button>` in React. Questo oggetto JSX\nprevede una props chiamata `onClick` che ci permette, appunto, di eseguire una funzione nel momento\nin cui il bottone viene chiamato.\n\nSe volete approfondire l'utilizzodo di `useState` potete dare un'occhiata alla [documentazione ufficiale](https://it.reactjs.org/docs/hooks-state.html).\n\n### Eseguire codice dopo un rendering del component con `useEffect`\n\nAbbiamo visto il funzionamento di `useState` e di come può essere utile per controllare il rerendering del\nnostro componente react. Un altro hook molto usato ed importante è l'hook `useEffect`, che ci permette\ndi eseguire del codice dopo che il componente viene renderizzato, e di controllare in quali situazioni eseguire\nquesto codice.\n\nAd esempio, se volessimo stampare sulla console del browser il valore di `value` ogni volta che questo cambia,\npossiamo aggiungere il seguente codice al nostro progetto:\n\n```diff\n- import { useState } from \"react\";\n+ import { useEffect, useState } from \"react\";\n\nconst ExperimentsPage = () => {\n  const [value, setValue] = useState(10);\n\n+  useEffect(() => {\n+    console.log(`valore di value = ${value}`)\n+  }, [value]);\n\n...\n};\n```\n\nDopo questa modifica, se proviamo ad aprire la console del browser (click destro dentro l'html e poi scegliamo \"ispeziona\", quindi\nspostiamoci sul tab **console**), vedrete che ad ogni rerender la funzione passata a useEffect viene eseguita.\n\n![Console](./console.png)\n\nLa sintassi di `useEffect` è un po' particolare, vediamo nel dettaglio come funziona. In particolare useEffect prende\ndue parametri, il primo è la funzione da eseguire, mentre il secondo è una tupla di _dipendeze_, che dice\nallo `useEffect` quando eseguire la funzione. Ad esempio, in questo caso gli abbiamo passato `[value]` come\ndipendenza, e quindi la funzione verrà eseguita solo nel momento in cui il valore di `value` cambia.\n\nPossiamo creare `useEffect` che vengono esegiuti al primo rendering del componente passando `[]` come dipendenze.\n\nSe volete approfondire l'utilizzodo di `useEffect` potete dare un'occhiata alla [documentazione ufficiale](https://it.reactjs.org/docs/hooks-effect.html).\n\n### Creiamo un conto alla rovescia\n\nAbbiamo tutti i componenti, adesso, per iniziare a fare qualcosa di leggermente più complesso: possiamo\nsfruttare insieme lo `useState` e lo `useEffect` per creare un componente che si occupa di effettuare\nun classico conto alla rovescia. Facciamolo insieme e poi vediamo di usarlo all'interno della nostra pagina.\n\n```tsx\nconst Timer = () => {\n  const [cnt, setCnt] = useState(10);\n\n  useEffect(() => {\n    if (cnt > 0) {\n      setTimeout(() => {\n        setCnt((s) => s - 1);\n      }, 1000);\n    }\n  }, [cnt]);\n\n  if (cnt > 0) {\n    return <p>Mancano {cnt} secondi!</p>;\n  }\n  return <p>Timer scaduto!</p>;\n};\n```\n\nAndiamo a vedere cosa abbiamo fatto.\n\nPer prima cosa abbiamo creato una stato `cnt` inizializzato a 10. Questo conterrà il valore del nostro timer.\n\n```jsx\nconst [cnt, setCnt] = useState(10);\n```\n\nA questo punto, usiamo `useEffect` insieme ad una funzione nativa del browser chiamata `setTimeout`, che ci permette\ndi eseguire una funzione, in questo caso quella che si occupa di decrementare lo stato `cnt`, dopo un certo intervallo\ndi tempo (in questo caso 1000 milli secondi, cioè 1 secondo).\n\n```tsx\nuseEffect(() => {\n  if (cnt > 0) {\n    setTimeout(() => setCnt((s) => s - 1), 1000);\n  }\n}, [cnt]);\n```\n\n`setTimeout` viene chiamata solo se `cnt > 0`, altrimenti lo useEffect non fa nulla e il time si ferma.\n\nCerchiamo di capire cosa succede:\n\n1. Al primo rendering, abbiamo `cnt = 10`. Lo `useEffect` imposta il timeout in modo che, dopo un secondo, la funzione\n   `() => setCnt((s) => s - 1)` viene chiamata e setCnt modifica lo stato a `9`.\n2. Quando lo stato passa a 9, `useEffect` viene di nuovo triggerato, e prepara il setTimeout a decrementare nuovamente\n   `cnt`. Questo processo viene ripetuto fino a che `cnt` non assume valore `0`.\n3. Quando `cnt` diventa zero, lo `useEffect` non farà nulla e il timer si fermerà.\n\nPer finire, usiamo uno `if` statement per renderizzare cose diverse in base al valore di `cnt`:\n\n```tsx\nif (cnt > 0) {\n  return <p>Mancano {cnt} secondi!</p>;\n}\nreturn <p>Timer scaduto!</p>;\n```\n\nPossiamo inserire il nostro `Timer` all'interno della pagina principale per vederlo funzionare:\n\n```tsx\n<div>\n  <Timer />\n</div>\n```\n\nE dovreste ottenere un risultato simile a questo:\n\n![Timer](./timer.png)\n![Timer Scaduto](./timer-scaduto.png)\n\n## Componenti React Riutilizzabili\n\nFin qui abbiamo visto come possiamo utilizzare i componenti React per gestire diverse parti\ndella nostra applicazione che si ripetono (come nel caso di `Nav` e `Footer`), e come\nusarli per avere un'applicazione in grado di interagire con l'utente (vedi `Timer`).\n\nUn'altro uso molto comune dei component React è quello di creare parti dell'applicazione\nche si ripetono, visualizzando dati diversi.\n\nUn blog ad esempio, che ha bisogno di una lista di post da visualizzare, può facilmente\nessere modellato in React tramite un component `PostPreview` che prende in\ningresso i metadati del post (titolo, autore, etc.). Una volta ottenuti i dati (tramite chiamata API al backend)\no in un altro modo (vedremo in seguito come), possiamo semplicemente, tramite un ciclo for, generare una\nlista di `PostPreview` da renderizzare a partire dalla lista di post che abbiamo.\n\nAndaimo ad implementare questa funzionalità con un compoent.\n\nPer prima cosa abbiamo bisogno del modello (tipi di dati) che ci servono e che verranno passati al componente.\nDato che il nostro componente si chiama `PostPreview`, definiamo un'interfaccia `PostPreviewProps`\n\n```tsx\ninterface PostPreviewProps {\n  title: string;\n  published: string;\n  author: string;\n  readTime: number;\n}\n```\n\nA questo punto possiamo creare un component che renderizza queste informazioni:\n\n```tsx\nconst PostPreview = (post: PostPreviewProps) => {\n  let timeMin = 'minuti';\n  if (post.readTime === 1) {\n    timeMin = 'minuto'\n  }\n  return <span>{post.title} by {post.author} - <emph>{post.timestamp}</emtp> - lettura in {post.readTime} {timeMin}</span>;\n};\n```\n\nIl nostro componente è finito. Sarà molto semplice (al solito) ma già implementa un po' di logica che ci permette di cambiare\nleggermente il suo comportamento in base al contenuto `post.readTime`. In questo modo possiamo scrivere, in modo corretto,\n\n- lettura in 10 minuti\n- lettura in 1 minuto\n\nPer utilizzarlo ci servono però una lista di post. Dato che non abbiamo ancora visto come prenderli (e da dove), usiamo dei dati\nfinti per il momento. Definiamo, all'interno del componente pagina, un array di post in questo modo:\n\n```tsx\nconst posts: PostPreviewProps[] = [\n  {\n    title: \"Primo post\",\n    timestamp: \"un minuto fa\",\n    author: \"Ludovico Russo\",\n    readTime: 10,\n  },\n  {\n    title: \"Un altro post\",\n    timestamp: \"due giorni fa\",\n    author: \"Ludovico Russo\",\n    readTime: 1,\n  },\n];\n```\n\nA questo punto, possiamo usare la funzione `posts.map()` (ve la ricordate, l'abbiamo già incontrotata), per\ncreare una lista di componenti `PostPreview` a partire dalla nostra lista di post:\n\n```tsx\n<div>\n  <h3>I miei post</h3>\n  <ul>\n    {posts.map((post, idx) => (\n      <li key={idx}>\n        <PostPreview {...post} />\n      </li>\n    ))}\n  </ul>\n</div>\n```\n\nCerchiamo di capire cosa abbiamo fatto:\n\n```tsx\n<ul>\n  {posts.map((post, idx) => (\n    <li key={idx}>\n      <PostPreview {...post} />\n    </li>\n  ))}\n</ul>\n```\n\n`<ul>` e `<li>` sono i tag html per creare delle liste. Abbiamo quindi creato una _unordered list_ `<ul>`\ncontenente un tag `<li>` per ogni post.\n\n```tsx\nposts.map((post, idx) => (\n  <li key={idx}>\n    <PostPreview {...post} />\n  </li>\n));\n```\n\n`posts.map()` ci permette di ciclare all'interno dei nostri `posts` e di ritornare un array di elementi JSX, ognuno contentente un tag `<li>`\ncon all'interno l'oggetto `PostPreview`. Notare che passiamo al tag `<li>` la prop `key={idx}`. Questa sintassi è necessaria a React\nper distinguere tra diversi componenti uguali quando vengono definiti dentro un array. In generale, per non incorrere in bug nel rendering,\nogni volta che abbiamo un `.map()` che ritorna un componente JSX dobbiamo passare una key all'elemento padre che ritorniamo. Il contenuto della key non\nè importante, ma deve essere univoco. Possiamo passargli la posizioen dell'oggetto nell'array (come in questo caso),\noppure un altro valore univoco (ad esempio avremmo potuto passare il `post.title`).\nNormalmente, per dati che arrivano da un database e che contengono un identificativo univoco, solitamete si passa questo identificativo come key (lo vedremo sicuramente in seguito).\n\nPer finire, renderizzaimo il nostro componente passandogli il post specifico:\n\n```tsx\n<PostPreview {...post} />\n```\n\nDa notare la sintassi `{...post}`, che non è altro che lo spread operator. Adremmo potuto anche scriverlo in forma non compatta in questo modo:\n\n```tsx\n<PostPreview\n  title={post.title}\n  timestamp={post.timestamp}\n  author={post.author}\n  readTime={post.readTime}\n/>\n```\n\nEd ecco il risultato:\n\n![Lista di post](./posts.png)\n\n## Organizzare i componenti in differenti file\n\nPer il momento abbiamo scritto del codice molto disordinato, inserendo tutte le definizioni di componenti all'interno dello stesso file.\nSpesso è una cosa utile e veloce da fare, ma in caso di componenti da usare in più punti (e diverse pagine) della nostra applicazione\ndobbiamo pensare ad un modo per strutturare il progetto in modo più organizzato.\n\nIl modo suggerito da NextJS, nonchè quello che io seguo principalmente, è quello di creare una cartella `components/` dentro il\nquale definire un file per ognuno di questi componenti. Alcune programmatori sono molto seri nell'applicare questo principio, mentre io\nproferisco essere più pigro e spostare i componenti all'interno di questa cartella solo quando so che mi serviranno in più di una pagina.\n\nIn generale, cerchiamo di tenere all'interno di questa cartella un componente per ogni file che definiamo.\n\nQuindi, come possiamo migliorare l'organizzazione del codice? Per il momento siamo sicuri solo che i nostri componenti `Nav` e `Footer`\nsaranno usati più o meno da tutte le parti della nostra applicazione, quindi possiamo spostarli in file separati, rispettivamente in\n`components/nav.tsx` e `components/footer.tsx`.\n\n```tsx\n// components/nav.tsx\nexport const Nav = () => {\n  return <nav>React Megaturial Navigation</nav>;\n};\n```\n\n```tsx\n// components/footer.tsx\nexport const Footer = () => {\n  return <footer>React Megaturial; all right reserverd</footer>;\n};\n```\n\nA questo punto, ricordiamo di importarli nella nostra pagina per poterli utilizzare:\n\n```diff\n// pages/experiments.tsx\nimport { useEffect, useState } from \"react\";\n+ import { Footer } from \"../components/footer\";\n+ import { Nav } from \"../components/nav\";\n\n// ...\n```\n\n## Cosa abbiamo imparato?\n\n- Cosa sono i Componet React e come possono essere utilizzati;\n- Come scomporre l'applicazione in diversi componenti indipendenti;\n- Come usare manipolare lo stato dentro un componente tramite gli Hook `useState` e `useEffect`;\n- Come usare le props di un componente per renderizzare dati diversi;\n- Come organizzare i componenti riutilizzabili in file diversi;\n\nIl codice di questo capitolo lo [trovate su github](https://github.com/ludusrusso/next-js-megatutorial/tree/c2).\n",
          "slug": "react-components",
          "frontMatter": {
            "title": "Introduzione ai React Components",
            "readTime": 16,
            "imagePath": "/courses/nextjs-megatutorial/00003-react-components",
            "description": "Come funzionano i React Components e come possiamo usarli per costrire la nostra applicazione",
            "published": true
          }
        },
        {
          "file": "/Users/ludovicorusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/00004-stilizziamo-component/index.mdx",
          "content": "",
          "slug": "component-styling",
          "frontMatter": {
            "title": "Stilizziamo i componenti",
            "readTime": 1,
            "imagePath": "/courses/nextjs-megatutorial/00004-stilizziamo-component",
            "description": "Lo stile dei componenti è un'attività essenziale ma molto complessa. In questa guida non voglio insegnarvi ad usare lo stile, ma presentarvi alcune tecniche molto utili per iniziare ad aggiungere stile ai nostri component.",
            "published": false
          }
        }
      ],
      "author": "ludusrusso",
      "title": "NextJS Mega Tutorial",
      "readTime": 3,
      "href": "/courses/nextjs-mega-tutorial",
      "imagePath": "/courses/nextjs-megatutorial",
      "description": "NextJS e React sono dei tool molto usati nel mondo dello sviluppo web moderno. Chiunque voglia diventare uno sviluppatore web può puntare su questi progetti per iniziare ad imparare e sviluppare i propri progetti."
    }
  }
]