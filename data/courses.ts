// autogenerated by /Users/ludusrusso/develop/github.com/ludusrusso/www.ludusrusso.dev/scripts/build-courses.ts. Do not edit!

export type Course = typeof courses[number]
export type CourseChapter = Course["frontMatter"]["toc"][number]
export const getCourses = () => courses
export const getCourse = (slug: string) => courses.find(course => course.slug === slug)
export const getCourseChapter = (slug: string, cslug: string) =>
  courses
    .find((course) => course.slug === slug)
    ?.frontMatter.toc.find((chapter) => chapter.slug === cslug);

const courses = [
  {
    "file": "/Users/ludusrusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/index.mdx",
    "content": "\nNextJS e React sono dei tool molto usati nel mondo dello sviluppo web moderno. Chiunque voglia diventare\nuno sviluppatore web può puntare su questi progetti per iniziare ad imparare e sviluppare i propri progetti.\n\nQuesto corso, raccolto qui come un lungo e completo tutorial, è un mio piccolo esperimento per iniziare\nla scrittura di un libro completo ed introduttivo rivolto a persone che vogliono avvicinarsi in modo completo\nal mondo dello sviluppo web.\n\nIl corso sarà composto di una serie di capitoli con materiale misto tra video tutorial e materiale scritto. Inoltre,\nla parte scritta di questo corso sarà resa gratuitamente disponibile all'interno del mio blog per\nchiunque voglia visualizzarlo.\n\nIl corso è in fase di scrittura, e chiedo a chi lo seguirà di darmi il più possibile feedback e suggerimenti per renderlo\npiù completo e più utile ai più. A breve, inoltre, renderò possibile agli interessati ad iscriversi al corso\nper accedere a tutto il materiale che sto producendo ad un prezzo vantaggioso! Quindi rimanete sintonizzati\nsu questo blog per saperne di più!\n\n## Introduzione\n\nBenvenuti nel mio progetto **NextJS Mega Tutorial**!\nIn questa serie di articoli voglio condividere la mia esperienza nello sviluppo reale di applicazioni con NextJS e Javascript.\nInsieme vederemo come sviluppare e deployare applicazioni complete usando NextJS, React e l'ecosistema Javascript.\n\nA differenza di molte altre risorse e tutorial che si trovano in rete, **NextJS Mega Tutorial** vi porterà all'interno di\nun viaggio nello sviluppo software completo. Insieme non vedremo esempi isolati, ma vi mostrerò qual è il processo completo\nper sviluppare applicativi web completi e non banali.\nQuando raggiungeremo la fine del viaggio, avremmo sviluppato insime un progetto completo di cui conoscerete ogni linea di codice.\nCosa più importante, capirete nel dettaglio tutte le tecnologie, i concetti e le tecniche che utilizzano gli sviluppatori\nprofessionali per creare progetti complessi, e sarete in grado di applicare questi concetti ai vostri progetti personali e lavoriativi.\n\n## Prerequisiti\n\nPer ottenere il massimo da questa serie di tutorial devi avere una minima esperienza nello\nsviluppare applicativi con Javascript. Se hai sviluppato siti internet (o parti di questi)\nusando _Vanilla Javascript_ o librerie come _JQuery_ dovrebbe andare bene.\n\nUna minima conoscenza di HTML e CSS è anchenecessaria. Come nel caso di Javascript, una\nesperienza base con queste tencologie è sufficiente. Io assumo che tu sappia come creare\nuna semplice pagina HTML usando elementi come `<p>`, `<h1>`, `<img>` e `<div>`, e come usare\nCSS per applicare stili a questi elementi.\n\nUna conoscenza base della command line del sistema operativo è anche utile.\nPasseremo la maggior parte del tempo ad implementare codice nell'editor di testo, ma alcune\noperazioni devono necessariamente essere eseguite dalla commmand line del sistema operativo.\n\nSe usi Windows, consiglio di usare [il sottosistema Windows per Linux](https://docs.microsoft.com/it-it/windows/wsl/about),\nche mette a disposizione una bash compatibile con i comandi UNIX e bash, node.js e gli altri comandi che utilizzeremo. Usare\nwindows con PowerShell è possibile ma richiederà alcune modifiche alla command line rispetto a quelle che userò io in questa serie\ndi tutorial. Su Mac o Linux potete usare il terminale integrato nel sistema operativo.\n\nCome editor di testo per scrivere consiglio di usare [Visual Studio Code](https://code.visualstudio.com/), l'editor di testo\ndi riferimento per lo sviluppo software (specialmente in ambito web), che potete scaricare gratuitamente dal sito su tutte le piattaforme.\n\nPer testare l'applicazione che svilupperemo, potete usare il vostro browser preferito.\nIl mio cosiglio è di usare Chrome o Firefox, che sono i browser più usati per lo sviluppo web, in quanto sono\ncompatibili con il plugin [React Developer Tool](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi),\nmolto utile per fare debug delle applicazioni React (la libreria grafica alla base di NextJS).\n\nQuesto corso sarà a disposizione in una combinazione di materiale in forma scritta e video. Il corso è a pagamento ma la parte\nscritta del tutorial è anche disponibile gratuitamente su questo blog.\n\nPronto per iniziare? Il primo capitolo ti aspetta!\n",
    "slug": "nextjs-mega-tutorial",
    "frontMatter": {
      "toc": [
        {
          "file": "/Users/ludusrusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/00001-javascript-moderno/index.mdx",
          "content": "\nIl linguaggio di programmazione JavaScript è evoluto tantissimo negli ultimi\nanni. Purtroppo, siccome i browser sono lenti ad adottare le nuove funzionalità e\ncambiamenti, molti sviluppatori non sono riusciti ad aggiornarsi sulle nuove funzionalità.\n\nReact (e quindi NextJS) incoraggiano gli sviluppatori ad usare le funzioni moderne di JavaScript,\nper questo motivo questo capitolo è incentrato su un piccolo aggiornamento delle principali\nfeatures di JavaScript moderno che andremo ad utilizzare durante questo corso.\n\n## ES5 vs ES6\n\nJavaScript è un linguaggio basato sulla specifica ECMAScript, mantenuta da [ECMA](https://www.ecma-international.org/), un'organizzazione\nnon-profit che si occupa di mantenere e gestire standard legati al mondo dell'informatica e dei sistemi di telecomunicazione.\n\nNel mondo JavaScript spesso vengono citati termini come _ES5_ e _ES6_ relative alla versioni\ndel lingaggio. Questi termini si riferiscono rispettivamente alle versioni 5 e 6 della specifica ECMAscript\ndefinite da ECMA. _ES5_ è stata rilasciata nel 2009 ed è considerata attualmente\nla versione base delle varie implementazioni, in quanto è supportata da una stragande maggioranza\ndi browser e sistemo mobile. _ES5_, invece, è stata rilasciata nel 2015. Questa versione introduce\ndiverse migliorie significative alla versione pricedente, e rimane compabile con _ES5_ (cioè un\nquasiasi programma implementato in _ES5_ può essere eseguito da un interprete _ES6_, ma non viceversa).\n\nDalla verisone _ES6_ in avanti, ECMA ha deciso di rilasciare aggiornamenti periodici (ogni anno)\nalle specifica, per questo motivo spesso con _ES6_ ci si riferisce a tutti i miglioramenti\nrilasciati dalla versione _ES6_ in avanti, quindi spesso il termine _ES6_ è usato non propriamente\nper indicare la versione _ES6_, ma per indicare tutte l'ultimo pacchetto di aggiornamenti rilasciati nell'anno in corso (si lo so,\nconfonde un po').\n\nCome fanno quindi i Browser a stare dietro un'evoluzione tanto rapida? Non lo fanno e non potrebbero farlo. Le ultime\nfeature rilasciate nelle versioni _ES6_ e i suoi aggiornamenti non sono garantiti essere implementati in tutti i browser.\nPer gli sviluppatori questo è un problema, perchè non hanno controllo sul tipo di browser su cui la loro applicazione\nverrà eseguita. Ci viene però incontro una tecnica chiamata [**transpiler**](https://en.wikipedia.org/wiki/Source-to-source_compiler),\nche consiste nel convertire programmi scritti in una versione moderna di JavaScript in una versione equivalente scritta\nutilizzando _ES5_ che garantisce una compatibilità con (quasi) tutti i browser. I transpiler sono integrati in tutti\ni principali framework moderni JavaScript (e quindi in React a NextJS che usere in questo corso), e grazie a questi\ngli sviluppatori hanno molti meno vincoli e possono tranquillamente utilizzare le ultime feature di _ES6_.\n\n## Una carrellata delle Features moderne di JavaScript\n\nQuesto corso si basa su _ES6_, quindi mi sembra utile fare una breve carrellata, prima di iniziare, delle feature\npiù importanti che useremo di JavaScript e delle convezioni (in questo caso mie prefernze) che useremo per scrivere\ni vari programmi in questo corso.\n\n### Semicolon (punto e virgola) `;`\n\nLe regole di JavaScript riguardo quando usare il `;` sono poco chiare e spesso\nconfondono gli sviluppatori. Si dice che JavaScript, a differenza di altri linguaggi,\nnon richieda l'uso dei `;` per separare le istruzioni. Questo non è propriamente\nvero. Sebbene non sia necessario la maggior parte delle volte, in specifici casi\nil loro utilizzo è richiesto, e questo spesso porta a bug o ad un codice che si\ncomporta in modo diverso da quello che vogliamo.\n\nPer evitare questi problemi, io (e molti programmatori JavaScript) consiglio di\nusare sempre il `;` per chiudere le istruzioni. Non utilizzo il `;` dopo il\nsimbolo `}` alla fine di una dichiarazione di funzione o di un blocco di codice di una\nstruttura di controllo (come `if`, `for`, ecc.) in quanto è la prassi per molti\naltri linguaggi come `C/C++` e `Java`.\n\nEcco alcuni esempi:\n\n```javascript\nconst myVar = 1; // <- termine di un'istruzione di assegnazione\n\nfunction myFunc() {\n  console.log(\"funzione\"); // <- termine di un'istruzione di esecuzione\n} // <- qui non serve perchè chiude una dichiarazione di funzione\n```\n\nAttenzione a quando viene assegnata una funzione anonima (arrow function) ad una variable, in questo caso\nil `;` è necessario dopo il `}` per chiudere l'assegnazione.\n\n```javascript\nconst myFunc = () => {\n  console.log(\"funzione\");\n}; // <- termine di un'istruzione di assegnazione\n```\n\nOvviamente queste sono preferenze e consigli di stile adottati da molti sviluppatori (non tutti),\nquindi non è necessario che seguiate queste regole, ovviamente se sapete bene cosa state facendo.\n\nNon è nemmeno necessario ricordarle perfettamente, in quanto esistono tools, come prettier, che ci aiutano\nad uniformare lo stile in fase di scrittura. Vedremo in futuro come usarle.\n\n### Trailing commas (virgole finali)\n\nQuando definiamo un oggetto o un array su più di una linea, è molto utile inserire una virgola\nanche dopo l'ultimo elemento.\nQuesta sintassi può sembrare scorretta ma JavaScript (insieme a molti altri linguaggi come Go ad esempio)\nlo permettono.\n\nEcco alcuni esempi:\n\n```javascript\nconst myArr = [\n  1,\n  2,\n  3, // <- virgola qui\n];\n\nconst myObj = {\n  name: \"Ludovico\",\n  age: 33, // <- virgola qui\n};\n```\n\nCi sono due vantaggi ad usare questa sintassi:\n\n1. Possiamo spostare tutti gli elementi senza preoccuparti di rompere la sintassi,\n2. Quando dobbiamo aggiungere un nuovo elemento alla fine, lo possiamo fare senza preoccuparci di aggiungere la virgola all'elemento precedente.\n\n## Import ed export\n\nSe sei abituato a scrivere applicazioni _old-style_ in JavaScript per il browser, probabilmente\nnon hai mai abuto bisogno di importare o esportare codice javascript. Potevi semplicemente\nrichiedere al browser di caricare i file javascript usando il tag `<script>` in HTML.\nIn questo modo tutte le definizioni e le funzioni dichiarate nel codice è accessibile\ntramite come scope _globale_ all'interno della pagina nel browser.\nSebbene questo approccio funzioni, non è facilmente mantenibile e diventa un problema per\ngrossi progetti.\n\n_ES6_ introduce il concetto di _modulo_, cioè un insieme di funzioni e variabili che sono accessibili\ntramite _import_ ed _export_ all'interno di altri file. Grazie ai moduli il programmatore può controllare\nil codice da esportare e mettere a disposizione ad altri programmatori dal codice interno al modulo stesso.\n\nUn modulo JavaScript non è altro che un file javascript che contiene una serie di definizioni di funzioni, variabili e altri oggetti.\nDi default tutto ciò che è dichiarato all'interno del modulo è privato, cioè non è accessibile dall'asterno.\nSe però vogliamo esportare (quindi rendere pubblico) una di queste definizioni possiamo usare al keyword `export`:\n\n```javascript\n// myModule.js\n\nexport function myFunction() {\n  console.log(\"funzione esportata\");\n}\n```\n\nE importarla (per usarla) in un altro file con la keywork `import`\n\n```javascript\n// main.js\n\nimport { myFunction } from \"./myModule\";\n\nmyFunction();\n```\n\nLa sentassi che stiamo usando per importare si chiama _unpacking_, e ci permette di\nselezionare quali definizioni vogliamo importare dal modulo. Se sono più di una è possibile\nusare la virgola per listarle all'interno delle parentesi graffe.\n\nJavascript ci da anche la possibilità di esportare una definizione con la keyword `export default`,\nper ogni modulo possiamo solo esportare un oggetto usando `default`, e la sintassi per importarla\nnon prevedere le parentesi, come in questo caso\n\n```javascript\n// secondoModule.js\n\nexport default function mySecondFunction() {\n  console.log(\"funzione esportata usando default\");\n}\n\n// main.js\n\nimport mySecondFunction from \"./secondModule\";\n\nmySecondFunction();\n```\n\nIn questo caso possiamo decidere arbitrariamente il nome della funzione quando la importiamo, ad esempio\navremmo potuto scrivere\n\n```javascript\n// main.js\n\nimport myFunc from \"./secondModule\";\n\nmyFunc();\n```\n\nPossiamo anche usare contemporaneamente le due sintassi `export default` ed `export`, esattamente con le\nregole di prima.\n\n```javascript\n// multipleModule.js\n\nexport const PI = 3.14;\nexport const sqrt = (x) => {\n  return Math.sqrt(x);\n};\n\nexport default function circleArea(r) {\n  return PI * r * r;\n}\n\n// main.js\n\nimport circle, { PI, sqrt } from \"./multipleModule\";\n\n// oppure\n\nimport circle from \"./multipleModule\";\nimport { PI, sqrt } from \"./multipleModule\";\n```\n\nChiamando la funzione `myFunc`. Alcune librerie e framework JavaScript (come React ad esempio),\nconsigliano di utilizzare principalmente la sintassi con `export default`. Io in generale (ma questa è una mai\npreferenza) preferisco la sintassi con `export` normale, per due motivi:\n\n1. Ci permette di esportare più dichiarazioni dallo stesso file,\n2. Funziona meglio con tools di sviluppo che non supportano la sintassi `export default`.\n\nSe volete saperne di più, vi suggerisco di leggere le sezioni\n[import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) ed\n[export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) della documentazione di JavaScript.\n\n## Variabili\n\nOgni linguaggio di programmazione ha alla base il concetto di variabile, cioè simboli all'interno dei\nquali vengono salvate dei valori.\n\nAnche in questo caso, le versioni vecchie di JavaScript erano _incasinate_ (non so come dirlo in modo carino)\nsulla definizione di variabile. In particolare l'unico modo per definire una variabile era usare\nla keyword `var`, che però aveva un comportamento molto diverso rispetto agli altri principali linguaggi di\nprogrammazione. Non voglio entrare nel merito di questo, però l'utilizzo di `var` faceva si che il codice\nfacesse come strane come dare la possibilità di utilizzare una variabile prima della dichiarazione, che ovviamente\nportava a bug e problemi di comportamento nei programmi.\n\nPer ovviare a questo, _ES6_ ha introdotto due nuovi keywords: `let` e `const`, per la definizione di variabile, lasciando\n`var` per ragioni di retrocompatiblità ma con la forte raccomandazione di non usare più questa keyword. In generale\nla community JavaScript è abbastanza d'accordo sul fatto che `var` non debba proprio essere usata all'interno dei programmi.\n\nPer definire una variable, usiamo quindi la keywork `let`:\n\n```javascript\n// definiamo la variabile a\nlet a; // valore undefined\n\na = 10; // valore 10\n\n// definiamo e assegnamo un valore alla variabile b\nlet b = 1;\n```\n\nSe una variable è definita ma non assegnata con `let`, il suo valore di default sarà `undefined`.\n\nUna costante è una variabile che può essere assegnata solo nel momento della definizione, e non più dopo.\nTentare di riassegnare una variabile definita con `const` porterà ad un errore.\n\n```javascript\nconst c = 10;\n\nconsole.log(c);\n// Output: 10\n\nc = 11; // errore\n// Output: Uncaught TypeError: Assignment to constant variable.\n```\n\nMi piace parlare comunque di variabile e non di costante, perchè è possibile assegnare oggetti mutabili (cioè il cui valore\ncambia nel tempo, ad una variabile definita con `const`). Questo può sembrare un po' confusionario le prime volte, quindi vediamo\nun esempio:\n\n```javascript\nconst myArr = [1, 2, 3];\n\nmyArr.push(4);\n\nconsole.log(myArr);\n// Output: [1,2,3,4]\n```\n\nQuesto codice è lecito e funzionante, quello che non possiamo fare è riassegnare `myArr`. In generale\nuna variable `const` in JavaScript non può mai stare (se non la prima volta) a sinistra dell'istruzione di assegnazione\n`=`, e quindi non può essere riassegnata.\n\n```javascript\nmyArr = [1, 2]; // errore\n// Output: Uncaught TypeError: Assignment to constant variable.\n```\n\nPer maggiori informazioni potete consultare la documentazione di JavaScript per [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) e [`const`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const).\n\n## Comparazioni in JavaScript\n\nAnche in questo caso, le versioni vecchie di JavaScript erano un casino per quanto riguarda le istruzioni di comparazione,\ne con _ES6_ si è riusciti (finalmente) a mettere un po' di ordine.\n\nIn particolare, gli operatori originali di comparazione `==` e `!=` sono stati creati nuovi operatori: `===` e `!==`, che hanno un comportamente\nmatematicamente molto più corretto.\nGli operatori originali sono stati lasciati per retrocompatibilità, ma è consigliato usare gli operatori nuovi.\n\nAnche in questo caso non mi voglio dilungare troppo e vi dico solo di evitare sempre di usare `==` e `!=` per non\nincappare in bug e comportamente strani nel codice.\n\nVediamo come usarli:\n\n```javascript\nconst a = 1;\n\nconsole.log(a === 1); // Output: true\nconsole.log(a === \"1\"); // Output: false\nconsole.log(a !== 3); // Output: true\n```\n\nSiccome molti linguaggi di programmazione usano `==` e `!=` come operatori di comparazione,\nsuccede spesso di confonderli ed è quasi inevitale l'uso degli operatori originali nel codice.\nPer questo motivo consiglio vivamente (vedremo dopo come farlo) di installare un analizzatore di codice\nnel nostro editor di testo che ci avvertenga quando usiamo `==` e `!=`.\n\nPer ulteriori dettagli, consultate la documentazione di JavaScript per gli operatori [`===`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality) e [`!==`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_inequality).\n\n## Interpolazione di Stringhe\n\nQuando dobbiamo costruire una string a partire dal valore contenuto in una variabile,\npossiamo usare un'utilizza funzione di _ES6_ chiamata _template literals_.\n\nEcco un esempio:\n\n```javascript\nconst name = \"Ludovico\";\nconst saluti = `Ciao, ${name}!`;\n\nconsole.log(saluti);\n// Output: Ciao, Ludovico!\n```\n\nQuesta sintassi si usa all'interno di una stringa definita con il carattere ``` (backtick).\n\nPurtroppo per noi italiani non è semplice digitarlo sulla tastiera, in quanto non è un carattere che\nsolitamente usiamo. Sul mac (che uso io), si ottiene premente i tast `option + 9`, su linux possiamo usare\n`ALT + '` (ALT + apostrofo), mentre su windows digitando `ALT+96` (ALT e poi i caratteri `9` e `6`).\n\nTrovate più info sui _template literals_ sulla [doc apposita](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).\n\n## Cicli for\n\nIn JavaScript, è possibile definire un ciclo for in modo simile agli altri linguaggi, usando la sintassi\n\n```javascript\nfor (let i = 0; i < 3; i++) {\n  console.log(`i = ${i}`);\n}\n// Output:\n// i = 0\n// i = 1\n// i = 2\n```\n\nTuttavia, le versioni _ES6_ introduce un utile ciclo `for of`, che permette di iterare all'interno dei valori di un array\n\n```javascript\nconst names = [\"Ludo\", \"Silvia\", \"Carlo\"];\nfor (let name of names) {\n  console.log(`Ciao, ${name}!`);\n}\n// Output:\n// Ciao, Ludo!\n// Ciao, Silvia!\n// Ciao, Carlo!\n```\n\nAttenzione a non confonderlo con il `for in`, che itera all'interno delle `chiavi` un oggetto o array.\n\n```javascript\nconst names = [\"Ludo\", \"Silvia\", \"Carlo\"];\nfor (let id in names) {\n  console.log(`[${id}]: Ciao, ${names[id]}!`);\n}\n// Output:\n// [0]: Ciao, Ludo!\n// [1]: Ciao, Silvia!\n// [2]: Ciao, Carlo!\n```\n\n## Arrow function\n\n_ES6_ introduce una seconda per definire le funzioni, chiamate _arrow function_ o _fat arrow functions_.\n\nPer fare un esempio, consideriamo la funzione così definita:\n\n```javascript\nfunction mult(x, y) {\n  const res = x * y;\n  return res;\n}\n\nmult(2, 4); // Output: 8\n```\n\nCon la nuova sintassi possiamo definire la funzione in questo modo\n\n```javascript\nconst mult = (x, y) => {\n  const res = x * y;\n  return res;\n};\n\nmult(2, 4); // Output: 8\n```\n\nSebbene non sembri che cambi tanto, e i due modi possono sembrare ridondanti all'inizio. Questa seconda sintassi\npermette di scrivere codice più pulito e più conciso. Infatti, per funzioni che hanno una sola istruzione\nall'interno possiamo evitare le parentesi graffe e il `return`, riscrivendola così:\n\n```javascript\nconst mult = (x, y) => x * y;\n\nmult(2, 4); // Output: 8\n```\n\n```javascript\nconst PI = 3.14;\nconst circleArea = (r) => PI * r * r;\n\ncircleArea(2); // Output: 12.56\n```\n\nInoltre, le arrow functions permettono di avere una sintassi molto più pulita quando sono usate\ncome funzioni anonime passate come parametro ad altre funzioni. Per capire meglio facciamo un esempio.\n\nIn JavaScript è possibile creare un array a partire da un array originale usando la funzione `map`. Questa\nfunzione, di fatto, prende un array, esegue una seconda funziona a tutti gli elementi dell'array originale\ne ritorna un nuovo array con i risultati delle varie computazioni.\n\nQuesta sintassi\n\n```javascript\nconst nums = [1, 2, 3, 4, 5];\n\nconst doubleNums = nums.map(function (n) {\n  return n * 2;\n});\n// Output: [2, 4, 6, 8, 10]\n```\n\nPuò essere sostituita con la seguente che è molto più leggibile e concisa:\n\n```javascript\nconst nums = [1, 2, 3, 4, 5];\n\nconst doubleNums = nums.map((n) => n * 2);\n// Output: [2, 4, 6, 8, 10]\n```\n\nPer approfondire eccola la documentazione delle [arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).\n\n## Promise\n\nIn JavaScript, quasi tutte le operazioni che coinvolgono la comunicazione con qualcosa di esterno al programma (una chiamata network,\naccesso al filesystem, ecc) sono asincrone. Il termine vuol dire che il programma non viene bloccato mentre\naspetta la risposta e può continuare a fluire. Il meccanismo che usa JavaScript per modellare questo comportamento\nsono le _promise_.\n\nUna promise è un oggetto _proxy_ che viene ritornato da un'operazione asincrona. L'oggetto non contiene\nil risultato dell'operazione, ma ci permetterà di accedere al risultato una volta che l'operazione sarà terminata.\n\nL'accesso al risultato avviene tramite una funzione di callback, in particolare l'oggetto `Promise` mette a disposizione\ndue metodi principali: `then()` e `catch()`. Entrambi i metodi richiedono come unico parametro una funzione di callback:\n\n- La funzione che passiamo tramite `then()` viene eseguita nel momento in cui il risultato risulta disponibile.\n- La funzione che passiamo tramite `catch()` viene invece eseguita se l'operazione fallisce, e ci permette di gestire l'errore.\n\nTantissime librerie JavaScript (sia interne che di terze parti) fanno fortemente uso delle primise, per questo dobbiamo\ncapire bene il loro meccanismo.\n\nPartiamo con un esempio: il browser ci mette a disposizione una funzione `fetch` per fare chiamate http ad URL specifici.\nQuesta funzione ritorna una promise:\n\n```javascript\nfetch(\"https://jsonplaceholder.typicode.com/users/1\").then((res) =>\n  console.log(res)\n);\n```\n\nQuesta funzione esegue la chiamata `GET https://jsonplaceholder.typicode.com/users/1` in background (quindi senza bloccare il programma).\nNel momento in cui la chiamata ritorna un risultato, questo risultato viene passato alla funzione di callback dichiarate nel `then()` che\nlo stampa a video.\n\nLe promesse possono essere eseguite in sequenza (si dice `chained` in inglese) ritornando un'altra promise\nnella funzione di callback. Un caso molto comune è il seguente:\n\n```javascript\nfetch(\"https://jsonplaceholder.typicode.com/users/1\")\n  .then((r) => r.json())\n  .then((data) => console.log(data));\n```\n\nIn questo caso la prima promise è la chiamata http, e la funzione di callback di questa esegue il metodo `r.json()`: questo\nmetodo si occupa di convertire il risultato in un oggetto JSON e ritorna una promise per gestire il risultato una volta disponiible.\nQuesta seconda Promise viene quindi gestire tramite il secondo `then()` che stampa a video il risultato.\n\nPer gestire l'errore, possiamo invece usare il metodo `catch()`, come in questo caso:\n\n```javascript\nfetch(\"https://jsonplaceholder.typicode.com/users/1\")\n  .then((r) => r.json())\n  .then((data) => console.log(data));\n  .catch((err) => console.error(`Got and error: ${err}`));\n```\n\nLe promise mettono a disposizione anche altri metodi per gestirle ed eseguirne più di una contemporaneamente.\nPer maggiori informazioni vi lascio [alla documentazione](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n## `async` e `await`\n\nLe _promise_ offrono un'ottima astrazione per gestire le operazioni asincrone all'interno del codice JavaScript, ma\nil loro uso massiccio, specialmente in casi di una lunga catena di promises all'interno di varie chiamate del metodo `then()`,\nporta alla scrittura di codice difficile da capire e mantenere.\n\nPer questo, nel 2017, ECMAScript ha introdotto una nuova sintassi per gestire le promise, tramite le keywork `async` e `await`.\nGrazie alla nuova sintassi, possiamo definire una funzione come asincrona con la keywork `async`. Le funzione asincrone\nritorneranno sempre una promise, e al loro interno è possibile usare la keyword `await` per attendere il risultato della promise senza\nusare il metodo then.\n\nEcco un esempio del codice precedente gestiro con la nuova sintassi:\n\n```javascript\nasync function fetchData() {\n  const r = await fetch(\"https://jsonplaceholder.typicode.com/users/1\");\n  const data = await r.json();\n  console.log(data);\n}\n```\n\nCon questa sintassi le chiamate asincrone possono essere eseguite in sequenza. Da notare che questa sintassi non\npermette comunque di bloccare un interno programma quando viene generata una promise, in quanto è limitata\nall'interno di una singola funzione.\n\nGli errori nelle funzioni esincrone possono essere gestire con le istruzioni `try` e `catch`.\n\n```javascript\nasync function fetchData() {\n  try {\n    const r = await fetch(\"https://jsonplaceholder.typicode.com/users/1\");\n    const data = await r.json();\n    console.log(data);\n  } catch (err) {\n    console.error(`Got and error: ${err}`);\n  }\n}\n```\n\nCome detto prima, le funzioni asincrone ritorneranno sempre una primise, e quindi possono essere usate all'interno del codice\ncon la sintassi vista prima:\n\n```javascript\nfetchData().then(() => console.log(\"Done!\"));\n```\n\nO, in alternativa, possono essere usati all'interno di un'altra funzione asincrona:\n\n```javascript\nconst g = async () => {\n  await fetchData();\n  console.log(\"done\");\n};\n```\n\nLa sezione [async and await](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises#async_and_await)\ndella documentazioen di JavaScript è un buon punto di partenza se si vuole approfondire.\n\n## Spread Operator\n\nLo _spread operator_ `...` permette di espandere un array of un oggetto ed estrapolarne i suoi elementi.\nÈ difficile spiegare come funziona lato teorico, ma viene molto facile capirlo partendo da degli esempio.\n\nSupponiamo di avere un array di numeri e volerne calcolare il minimo. JavaScript ci mette a disposizione\nla funzione `Math.min()` che calcola il minimo tra più numeri passati come argomenti. Purtroppo min non prende\nun array, ma una lista di numeri, quindi non possiamo passargli direttamente l'array.\n\n```javascript\nconst myArr = [1, 2, 3, 4];\nconst min = Math.min(myArr[0], myArr[1], myArr[2], myArr[3]);\n```\n\nGrazie allo spread operator, possiamo estrapolare i valori all'interno dell'array e passarli alla funzione `Math.min()` in questo modo:\n\n```javascript\nconst myArr = [1, 2, 3, 4];\nconst min = Math.min(...myArr); // 4\n```\n\nL'operator può anche essere usato per concatenare o creare nuovi array a partire da uno o più array esistenti:\n\n```javascript\nconst myArr = [1, 2, 3, 4];\nconst myArr2 = [0, 3, ...myArr, 10]; // [0, 3, 1, 2, 3, 4, 10]\n```\n\nO per copare un array velocemente:\n\n```javascript\nconst myCopy = [...myArr];\n```\n\nPossiamo usare lo spread operator anche per fare la stessa cosa sugli oggetti;\n\n```javascript\nconst myObj = { name: \"Ludovico\" };\nconst mySecondOby = { ...d, age: 33 }; // {name: 'Ludovico', age: 33}\nconst myCopy = { ...d }; // {name: 'Ludovico'}\n```\n\nUn'interessante funzionalità è che ci permette di copiare un oggetto e ridefinirne alcune proprietà, come in questo esempio:\n\n```javascript\nconst myObj = { name: \"Ludovico\", age: 32 };\nconst myCopy = { ...myObj, age: 33 }; // {name: 'Ludovico', age: 33}\n```\n\nIn questo caso, quando abbiamo collisioni sui nomi delle proprietà, il valore risolutate è ottenuto utilizzando l'ultima\noccorrenza della collisione (in questo caso `age:33` vince su `age:32` in quanto definito dopo).\n\nCome al solito vi consiglio di dare un'occhiata alla [documentazione ufficiale](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) per approfondire.\n\n## Proprietà di oggetti: scorciatoie\n\nIn modo simile agli spread operator, JavaScript ci mette a disposizione delle scorciatoie per definire velocemente\ndegli oggetti. Consideriamo ad esempio il seguente codice:\n\n```javascript\nconst name = \"Ludovico\";\nconst age = 33;\nconst user = { name: name, age: age }; // {name: 'Ludovico', age: 33}\n```\n\nIn questo caso, la ripetizione di `age` e `name` può essere omessa, come in questo caso:\n\n```javascript\nconst user = { name, age }; // {name: 'Ludovico', age: 33}\n```\n\nLe sue sintassi sono equivalenti e producono lo stesso risultato. In generale se vogliamo inserire all'interno di un oggetto\nuna proprietà che ha lo stesso nome e lo stesso valore di una variabile possiamo usare questa sintassi abbreviata.\n\nOvviamente, possiamo mixare le due sintassi, come in questo caso:\n\n```javascript\nconst user = { name, age, active: true }; // {name: 'Ludovico', age: 33, active: true}\n```\n\n## Destructuring\n\nIl _Destructuring_ è un'altra scorciatoia sintattica per creare variabili a partire dal contenuto di un oggetto o di un array\nin modo veloce, ed è un po' il contrario di quello visto su.\n\nAd esempio, supponiamo di avere una tupla (leggi array) e di voler prendere i primi due elementi e assegnarli a due variabile:\n\n```javascript\nconst myTuple = [33, \"Ludovico\"];\nconst age = myTuple[0];\nconst name = myTuple[1];\n```\n\nPossiamo abbreviare questa sintassi in questo modo:\n\n```javascript\nconst [age, name] = myTuple;\n```\n\nCosa succede se il numero di elementi dell'array è diverso da quello delle varibili che assegnamo? In caso abbiamo più variabili\na sinistra che elementi dell'array a destra, le variabili in più avranno valore `undefined`. In caso contrario, i valori dell'array\neccedenti vengono semplicemente ignorati.\n\nPossiamo anche combinare questa sintassi con lo _spread operator_:\n\n```javascript\nconst arr = [1, 2, 3, 4, 5];\nconst [a, b, ...c] = arr; // a = 1, b = 2, c = [3, 4, 5]\n```\n\nIn questo caso lo spread operator deve essere sempre l'ultimo elemento definito.\n\nLa stessa sintassi può essere usata per gli oggetti:\n\n```javascript\nconst user = { name: \"Ludovico\", age: 32 };\nconst { name, age } = user;\n```\n\nQuesta sintassi non deve necessariamente essere usata solo nell'assegnazione diretta, ma anche all'interno degli argomenti di funzione.\nAd esempio, possiamo semplificare questo codice:\n\n```javascript\nfunction f(user) {\n  console.log(user.name, user.age);\n}\n\nconst user = { name: \"susan\", active: true, age: 20 };\nf(user);\n```\n\nIn questo modo:\n\n```javascript\nfunction f({ name, age }) {\n  console.log(name, age);\n}\n\nconst user = { name: \"susan\", active: true, age: 20 };\nf(user);\n```\n\nIn questo caso, la funzione `f()` accetta un oggetto come argomento, ma invece di prenderlo interamente,\nprende solo le sue proprietà `name` e `age` scartando il resto.\n\nCome nel caso degli array, se le proprietà che vogliamo estrapolare non è definita gli viene assegnato il valore `undefined`.\n\nPotete approfondire questa sintassi in [questo articolo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) della documentazione.\n\n## Classi\n\nRispetto ai moderni linguaggi di programmazione, JavaScript non prevedeva il contetto di classe fino alla versione _ES6_.\nNon useremo molto le classi in JavaScript in generale, ma mi sembrava un'omissione troppo importante non accennarne nemmeno.\n\nEcco un esempio di cose si possono definire le classi in JavaScript:\n\n```javascript\nclass User {\n  // constructor (chiamato con `new User()`)\n  constructor(name, age, active) {\n    this.name = name;\n    this.age = age;\n    this.active = active;\n  }\n\n  // standard method\n  isActive() {\n    return this.active;\n  }\n\n  // async method\n  async read() {\n    const r = await fetch(`https://example.org/user/${this.name}`);\n    const data = await r.json();\n    return data;\n  }\n}\n\nconst user = new User(\"Ludovico\", 33, true);\n```\n\nPer saperne di più, vi rimando alla documentazione ufficiale di JavaScript: [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).\n\n## Estensioni di JavaScript: JSX e Typescript\n\nFino ad adesso abbiamo parlato di feature all'interno del linguaggio JavaScript, quello che in gergo viene chiamato _Vanilla Javascript_.\nIn questa e nella prossima sezione, invece, approfondiremo delle features che non fanno parte dello standard ECMAScript, e nemmeno\nsono pensate per esserle.\n\nIn entrambi i casi si parla di estensioni non standard del linguaggio, che possono essere usate solo tramite appositi _transpiler_ e che\nprobabilmente non verranno mai nativamente integrati nei browser e negli interpreti ufficiali: stiamo parlando di _JSX_ e _TypeScript_.\n\n### JSX\n\n[JSX](https://facebook.github.io/jsx/) sta per _JavaScript XML_, è un linguaggio ideato da Facebook ed alla base di _React_\nper rendere più semplice ed immediato la creazione di contenuto inline nel codice JavaScript, pensato specialmente\nper integrare HTML dentro i nostri programmi.\n\nPer esempio, se vogliamo creare un paragrafo HTML (`<p>`) in Vanilla JavaScript, possiamo usare le DOM API per fare una cosa\ndel genere:\n\n```javascript\nconst paragraph = document.createElement(\"p\");\nparagraph.innerText = \"Hello, world!\";\n```\n\nOvviamente, il codice diventa molto complesso se vogliamo genstire interi documenti HTML.\n\nIn JSX, invece, possiamo usare un linguaggio ibrido tra Vanilla JavaScript e HTML:\n\n```jsx\nconst paragraph = <p>Hello, world!</p>;\n```\n\nChe come vedete è molto più semplice e conciso.\n\nEcco un esempio di JSX più complesso:\n\n```jsx\nconst myTable = (\n  <table>\n    <tr>\n      <th>Name</th>\n      <th>Age</th>\n    </tr>\n    <tr>\n      <td>Ludovico</td>\n      <td>33</td>\n    </tr>\n    <tr>\n      <td>Silvia</td>\n      <td>20</td>\n    </tr>\n  </table>\n);\n```\n\nChe può anche essere migliorato usando un array e la funzione `map()`:\n\n```jsx\nconst users = [\n  {\n    name: \"Ludovico\",\n    age: 33,\n  },\n  {\n    name: \"Silvia\",\n    age: 20,\n  },\n];\nconst myTable = (\n  <table>\n    <tr>\n      <th>Name</th>\n      <th>Age</th>\n    </tr>\n    {users.map((user) => (\n      <tr>\n        <td>{user.name}</td>\n        <td>{user.age}</td>\n      </tr>\n    ))}\n  </table>\n);\n```\n\nJSX è una componente chiave di React (e quindi di NextJS). E avremmo modo di approfondirlo all'interno dei prossimi capitoli.\n\n### TypeScript\n\nCome JSX, anche TypeScript è un'estensione di JavaScript, o meglio un _superset_ del linguaggio JavaScript inventato da\nMicrosoft per migliorare la produttività degli sviluppatori.\n\nJavaScript è un linguaggio di programmazione senza tipi, cioè all'interno di una stessa variabile possiamo inserire\ndiversi tipi di dati, come numeri, array, stringhe o interi oggetti.\n\nIn JavaScript, un codice di questo tipo è valido:\n\n```javascript\nlet myNum = 2;\n\nmyNum = \"hello\";\n```\n\nIl problema principale è che questo tipo di funzionalità porta alla generazione di codice non matenibile e diventa\nproblematico in progetti che crescono. Un altro problema di JavaScript è dovuto al fatto che la mancanza di tipi rende\nmolto più difficile documentare il codice. Ad esempio, se abbiamo una funzione di questo tipo:\n\n```javascript\nfunction f(a, b) {\n  // codice\n}\n```\n\nDobbiamo leggere il codice per capire:\n\n1. Che tipi di dati devono essere `a` e `b`;\n2. Che tipo di dati la funzione torna (o anche se ha o no un valore di ritorno);\n\nIn generale è possibile estrapolare dal contesto (o tramite commenti) questo informazioni. Ma a lungo andare gli sviluppatori\nperdono molto più tempo a ricordarsi o cercare di capire queste informazioni piuttosto che scrivere del codice.\n\nL'idea di TypeScript è quella di creare un linguaggio che estende le funzionalità di JavaScript limitando quello che può fare\nlo sviluppatore ma rendendo il processo di sviluppo del software più robusto, semplice ed autodocumentato. Lo fa introducendo i\ntipi nel linaggio (o meglio le _type annotation_ alle variabili, che permettono di specificare il tipo di una variabile), insieme\nad una serie di tool e analizzatori in fase di sviluppo che aiutano il programmatore a sviluppare.\n\nAd esempio, in TypeScript, la funzione precedente può essere scritta cosi:\n\n```ts\nfunction f(a: number, b: number): number {\n  // codice\n}\n```\n\nIn questo caso, lo sviluppatore vede subito che `a` e `b` sono dei numeri e che la funzione ritorna un numero. Inoltre,\nse provassimo a chiamare la funzione in questo modo:\n\n```ts\nf(\"ciao\", 45);\n```\n\nRiceveremmo immediatamente un errore di sintassi che ci avverte di un problema. In JavaScript avremmo dovuto eseguire il\nprogramma per evitarlo.\n\nTypeScript introduce tantissime features interessanti sul linguaggio, che velocizzano tantissimo il processo di sviluppo.\nIl linguaggio è diventato tanto popolare che ormai la maggiorparte dei progetti JavaScript sono in realtà sviluppati in\nTypeScript, e la popolarità è talmente alta nella community che si sta iniziando a parlare di introdurre alcune funzionalità\ndi TypeScript nel linguaggio principale.\n\nSebbene non siamo obbligati ad usare TypeScript in Next e ReactJS, entrabi i progetti sono fortemente integrati\ncon TypeScript ed il consiglio generare è di usare TypeScript dal primo momento. Per questo motivo ho deciso di\nsviluppare interamente questo tutorial in TypeScript, e avremmo tempo di approfondire il linguaggio nel corso\ndei prossimi capitoli.\n\n### TypeScript + JSX = TSX\n\nOvviamente, entrambi le estenzioni possono essere usate insieme, in questo caso si parla di _TSX_. Eccone un esempio:\n\n```jsx\ninterface User {\n  name: string;\n  age: number;\n}\n\nconst users: User[] = [\n  {\n    name: \"Ludovico\",\n    age: 33,\n  },\n  {\n    name: \"Silvia\",\n    age: 20,\n  },\n];\n\nconst myTable = (\n  <table>\n    <tr>\n      <th>Name</th>\n      <th>Age</th>\n    </tr>\n    {users.map((user) => (\n      <tr>\n        <td>{user.name}</td>\n        <td>{user.age}</td>\n      </tr>\n    ))}\n  </table>\n);\n```\n",
          "slug": "javascript-moderno",
          "frontMatter": {
            "title": "Javascript Moderno",
            "readTime": 23,
            "imagePath": "/courses/nextjs-megatutorial/00001-javascript-moderno",
            "description": "JavaScript è in continua evoluzione, facciamo una breve carrellata delle feature di JavaScript moderno che andremo ad utilizzare in questo corso!",
            "published": true
          }
        },
        {
          "file": "/Users/ludusrusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/00002-primi-passi-nextjs/index.mdx",
          "content": "\nAbbiamo parlato in questa guida di React e NextJS. Prima di iniziare la parte cicciosa di questo tutorial,\ncerchiamo di capire meglio esattamente a cosa ci riferiamo.\n\nReactJS è una libreria sviluppata da Facebook per lo sviluppo di Interfaccia Grafica (UI) nelle applicazioni Web.\nA differenza di altri progetti a cui spesso è affiancato (come Angular o VueJS), React è una semplice libreria, nel\nsenso che mette a disposizione una serie di blocchi (funzioni, classi eccetera) allo sviluppatore ma non\nforsa (come nel caso dei framework) ad adottare una specifica architettura o organizzazione del codice. Inoltre, a differenza\ndi altri framwork, ReactJS non integra soluzioni a problemi noti nello sviluppo di applicazioni Web, come ad esempio\nla gestione del Routing (i cambi della pagina) o l'integrazioni come Api esterne: in questi casi gli sviluppatori sono\nliberi di integrare librerie nell'ecosistema React che preferiscono per risolvere i loro problemi come meglio credono.\n\nQuesto ha dato parecchi vantaggi negli anni a ReactJS, in quanto ha permesso all'ecossitema creatosi intorno alla libreria\ndi evolvere in modi diversi, senza limitazioni imposte dal team di sviluppo originale. In particolare, intorno a React sono\niniziati a nascere i cosidetti \"MetaFramework\", cioè progetti che estendevano la libreria originale imponendo scelte\narchitetturali alla creazione di un progetto. La cosa interessante, a mio avviso, è che molti di questi framework non\nsono rimasti relegati a pure applicazioni frontend (come nel caso di Angular), ma sono stati realizzati in modo da poter\npermettere la creazione di siti completi, integrando anche tecnologie backend.\n\nTra questi metaframework, i più rilevanti (almeno per il mio percorso) sono stati [Gatsby](https://www.gatsbyjs.com/) e [NextJS](https://nextjs.org/).\n\n**Gatsby** è stato uno dei primi framework ReactJS a permettere la creazione di siti statici (o prerenderizzati).\nEntreremo in futuro in questa guida nel dettaglio di cosa vuol dire prerendering, ma in generale quello che fa Gatsby è\ndare la possibilità allo sviluppatore di creare un sito in ReactJS composto da divere pagine, e (in fase di build), renderizzare\nl'intero progetto in modo da permettere di essere servito senza la necessità di avere un server web completo. Quest'idea, qualche anno fa,\nandava molto di moda in quanto permetteva agli sviluppatori di creare siti web completi con costi di hosting quasi (o completamente) nulli.\n\n**NextJS**, invece, porta l'idea di GatsbyJS al suo massimo, in quanto permette, all'intero di uno stesso framework, di controllare\npagina per pagina se effettuare il rendering lato frontend, lato backend, o entrambi. Con NextJS abbiamo il massimo della\nflessibilità nella creazione di siti web complessi, in quanto possiamo decidere in modo semplice e con delle API molto facili di utilizzare,\ncome una pagina deve essere renderizzata. Una pagina che contiene contenuti statici (come un blog post o un documento) può essere\nrenderizzata a buildtime ed avere un'inpatto minimo in termini di latenza e risorse per essere servita al cliente. Dall'altra parte\npagine che richiedono contenuti molto variabili possono essere renderizzate nel backend nel momento in cui viene fatta la richiesta\ndal cliente, come i classici siti web.\n\nQuesta capacità ha reso NextJS un progetto molto popolare nel modo JavaScript, che negli ultimi anni ha preso il sopravvento ed\nè sicuramente uno dei framework consigliati per realizzare siti web di tutti i tipi, dal blog personale a grandi siti aziendali.\n\n## Creazione del primo progetto NextJS\n\nPer poter utilizzare NextJS abbiamo bisogno di aver installato _node_ sul nostro terminale.\nQueta operazione è molto semplice, ed in generale consiglio di seguire la [guida del sito ufficila di Node](https://nodejs.org/en/).\n\nPer i più smanettoni, ed in particolare per chi vuole avere la possibilità di controllare puntualmente la versione di nodejs sul proprio\ncomputer, suggerisco di dare un'occhiata al progetto [NVM (Node Version Manager)](https://github.com/nvm-sh/nvm), che ci permette\ndi installare ed eseguire versioni diverse di node in modo semplice ed immediato.\n\nIn questo e nei prossimi passi, userò la versione di node _v16_, che al momento risulta essere la versione LTS (quella con supporto maggiore\nper interderci). Ad ogni modo, non dovrebbero esserci troppi problemi nell'utilizzare una versione di node successiva.\n\nUna volta installato node, per verificare che tutto funzioni correttamente, possiamo digiare il comando all'interno del terminale\n\n```bash\n$ node -v\nOutput: v16.14.0\n```\n\nche ci dirà quale versione di node abbiamo sul nostro sistema.\n\nPer creare un nuovo progetto, NextJS ci mette a disposizione il comando `create-next-app` che inizializzerà un progetto\nblueprint funzionante. Noi lo chiamere con l'opzione `--typescript`, per avere automaticamente installato il supporto a TypeScript.\n\n```bash\n$ npx create-next-app@latest --typescript\nNeed to install the following packages:\n  create-next-app@latest\nOk to proceed? (y) y\n✔ What is your project named? … my-first-site\nCreating a new Next.js app in /Users/ludusrusso/develop/next-js-megatutorial/my-first-site.\n\nUsing yarn.\n\nInstalling dependencies:\n- react\n- react-dom\n- next\n\n# ...\n```\n\nIl promt del tool ci chiederà alcune informazioni, intanto se vogliamo installare l'ultima versione del pacchetto `create-next-app`,\na coi ovviamente dovremmo rispondere di sì (digitando `y`). Inoltre ci chiederà che nome dare al progetto che stiamo creando.\nScegliete il nome che preferite (io ho scelto `my-first-site`), premete invio e attendete che l'installazione sia completata.\n\nVogliamo vedere se il sito funziona? Ci basta entrare nel progetto `cd my-first-site` e lanciare il server con il comando `npm run dev`.\n\n```bash\n$ npm run dev\n\n> my-first-site@0.1.0 dev\n> next dev\n\nready - started server on 0.0.0.0:3000, url: http://localhost:3000\nwait  - compiling...\nevent - compiled client and server successfully in 805 ms (125 modules)\n```\n\nA questo punto, apriamo il nostro browser preferito (io userò Chrome) e digitiamo l'indirizzo che vediamo\nnel prompt: `http://localhost:3000` per vedere il sito.\n\n![Primo sito web](./first-site.png)\n\nCome potete vedere, abbiamo appena eseguito il nostro sito web, che si presenta\ncome una pagina HTML base con rimandi alla documentazione e ai tutorial di NextJS.\n\nPer spegnere il server, ci basterà digirare sul terminale la combinazione `ctrl-C`.\n\n### Anatomia di un progetto NextJS\n\nPrima di iniziare a scrivere codice, credo sia importante iniziare ad esplorare\nil progetto per capire come è composto. Avremmo tempo di capire bene come\nmuoverci per bene tra i file di un progetto Next, ma credo sia importante\niniziare a riconoscere alcune cose fin dall'inizio.\n\nSe non lo avete già fatto, aprite il progetto con il vostro editor di testo.\nCome ho detto io userò in questa guida [VSCode](https://code.visualstudio.com/), che consiglio\ncaldamente a tutti voi in quanto è molto ben integrato con il mondo JavaScript e React. Inoltre,\nvi farò vedere più avanti alcuni tool ed estenzioni molto utili per\nvelocizzare lo sviluppo basati proprio su VSCode.\n\n> Se avete installato il [command line tool di VSCode](https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line), potete aprire VSCode nella cartella corrente semplicemente digitando `code .` all'interno della cartella del vostro progetto.\n\nIl progetto dentro VSCode dovrebbe apparirvi in questo modo:\n\n![VSCode](./vscode-project.png)\n\nNon ci addentremo in tutti i file del progetto, ma vediamo insieme i più importanti.\n\n#### Il file `package.json`\n\nIl file `package.json` è il principale file di ogni progetto node, all'interno\ndel file troviamo le definizioni delle dipende del nostro progetto, alcuni\nscript che vogliamo eseguire ed informazioni utilizi sul progetto.\n\nDalla sezione `dependencies` vediamo che il nostro progetto si porta dietro\nsolo 3 dipendenze: `next`, `react` e `react-dom`.\n\n```json\n{\n  ...\n  \"dependencies\": {\n    \"next\": \"12.1.6\",\n    \"react\": \"18.1.0\",\n    \"react-dom\": \"18.1.0\"\n  }\n}\n```\n\nNon c'è molto da dire di queste dipendenze, se non, cosa che sapeva già, che\nil progetto che abbiamo creato è un progetto NextJS e React.\n\nIn particolare `react` e `react-dom` sono alla base di ogni progetto React,\nin quanto contengono, rispettivamente, la libreria princiapale e la parte\nche permette alla libreria di agire sul Documento HTML (DOM). Come vedete stiamo\nusando la versione di react 18, che è l'ultima versione rilasciata nel momento\nin cui scrivo.\n\nLa dipendenza `next` invece include tutte le funzionalità di `NextJS`. Anche in\nquesto caso stiamo usando la verisone `12`, l'ultima major release rilasciata\nnel momento in cui scrivo questo articolo.\n\nSpostandoci nella sezione _scripts_, vediamo che nextjs ci prepara degli\nscript di default per agire sulla nostra applicazione.\n\n```json\n{\n  ...\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  }\n}\n```\n\nGli scirpt possono essere eseguiti con il comando `npm run <nome-script>`, e\ncome immagino molti di voi avranno capito, quando prima abbiamo eseguito il comando\n`npm run dev` stavamo lanciando lo script `dev` di questa sezione.\n\nPer ora ci interesserà principalmente lo script `dev`, che ha appunto lo scopo\ndi lanciare il server next in modalità di sviluppo. `build` ci permette\ninvece di _buildare_ l'applicazione e prepararla per essere eseguita in produzione,\nmentre `start` ci permette di _avviare_ l'applicazione precedentemente buildata. Questi\ndue scirpt ci serviranno nei prossimi capitoli quando ci occuperemo di rilasciare\nil nostro sito web in produzione.\n\nPer finire, il comando `lint` ci permette di lanciare il linter del codice, che\nverificherà che non ci siano problemi o warning a livello di sintassi JavaScript.\nIn generale la fase di lint viene eseguita prima di ogni build, quindi non useremo\nmolto questo comando.\n\nPer finire, nella sezione `devDependencies` troviamo tutte le dipendenze che sono\nutili al progetto in fase di sviluppo ma che non servono per la produzione.\n\n```json\n{\n  \"devDependencies\": {\n    \"@types/node\": \"17.0.32\",\n    \"@types/react\": \"18.0.9\",\n    \"@types/react-dom\": \"18.0.3\",\n    \"eslint\": \"8.15.0\",\n    \"eslint-config-next\": \"12.1.6\",\n    \"typescript\": \"4.6.4\"\n  },\n  ...\n}\n```\n\nPartiamo da `typescript`, che è la libreria che ci permette di usare ed interpretare\nil codice in linguaggio typescript. Come abbiamo visto nei capito precedenti, TypeScript\nnon è un linguaggio che viene interpretato nativamente dal Browser o in generale dagli interpreti\nJavaScript. Per questo motivo lo troviamo tra le dipendenze di dev. Una volta buildato il progetto\nsemplicemente tutto il codice Typescript sparisce e viene _transpilato_ in puro JavaScript.\n\nTutte le dipendenze che iniziano con `@types` sono necessarie per\navere le definizioni `typescript` di librerie implementate in JavaScript puro. Sono essenzialemnte\nun'aggiunta alla libreria principale in modo da far sapere al nostro editor di testo quali sono i\ntipi e le funzionalità TypeScript della libreria originale. Non è importante per noi sapere esattamente\nil funzionamento, vi basti sapere che è prassi, per molte librerie, definire i tipi TypeScript in una libreria\nseparata. Ne incotreremo alcune nei prossimi capitoli.\n\nPer finire, le due dipendenze `eslint` e `eslint-config-next` riguandano il linter (quindi l'analizzatore del codice),\nche ovviamente ci serve solo in fase di sviluppo e non è necessaria quando facciamo il deploy in produzione.\n\n> È compito dello sviluppatore sapere quali dipendenze vanno installate come `devDependencies` e quali come `dependencies`. Molti sviluppatori, poco attenti o poco esperti, tendono ad installare tutto all'interno della sezione `dependencies`. Sebbene questo non comporti un grosso problema nel funzionamento del progetto, diventa sicuramente un problema di ottimizzazione in quanto il pacchetto finale che andrà in produzione sarà molto più pensante del necessario.\n\n#### `npm` VS `yarn`\n\nLe dipendenze in un progetto node si gestiscono attraverso dei programmi\nchiamati _package manager_. Il package manager ufficiale di node è `npm`\n(che sta appunto per _node package manager_). Questo package manager ha avuto\nstoricamente alcuni problemi di funzionamento, tanto da costringere la community\na sviluppare package manager alternativi per risolvere questi problemi. `yarn`, sviluppato\nda facebook, è uno dei package manager alternativi più comuni nel mondo node, ed in\nparticolare molto usato nel mondo React.\n\nPer questo motivo, se vi addentrerete nel mondo dello sviluppo software JavaScript,\ntroverete spesso l'utilizzo quasi indistinto delle due tecnologie, `npm` e `yarn`.\nNel loro utilizzo cambia di fatto veramente poco, ma in generale ormai da qualche anno\nla differenza tra i due progetti è praticamente inesistente.\n\nPotete usare a piacere `npm` o `yarn`, di fatto (se non in alcuni comandi) non ho mai trovato\nrealmente delle differenze tra i due. Per mia scelta, in questo progetto, userò solamente\nil comando `npm`. Un po' per semplificare le cose (richiede una dipendenza in meno dato che il comando\nnpm è automaticamente installato con node), un po' perchè tra le due è sempre stato il mio\ncomando di default.\n\nDetto questo, cosa cambia nel pratico? NextJS usa yarn di default, ve ne accorgenete perchè\ntrovate il file `yarn.lock` all'interno del progetto. Per passare a `npm` è sufficiente\ncancellare il file e difitare il comando `npm install`.\n\n```bash\n$ npm install\n\nchanged 1 package, and audited 230 packages in 1s\n\n68 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n```\n\nVedrete che apparirà un nuovo file `package-lock.json` che è l'equivalente npm i `yarn.lock`.\nQuesti file rappresentano uno screenshot delle dipendenze che abbiamo installato (comprese quelle indiritte, cioè dipendenze delle dipendenze),\ne permettono al sistema di ricostruire in futuro esattamente l'attuale installazione anche su altri computer o sistemi diversi.\n\nPiccola nota, uno dei principali problemi di giovinezza di `npm` era l'assenza di questo file che rendeva il porting di progetti tra diversi\nsistemi instabile.\n\nIl file `package-lock.json` non deve mai essere modificato da uno sviluppatore, è automaticamente gestito dal package manager, quindi non\nè importante vedere cosa troviamo al suo interno. Sappiate solo che esiste.\n\n#### Typescript\n\nAbbiamo inizializzato il nostro progetto con Typescript, e questa cosa\nsi porta dietro due cose importnati su cui voglio puntare la vostra attenzione.\n\nIntanto troviamo un file `tscondig.json` che è il file di configurazione per Typescript.\nIn particolare questo file contiene alcune informazioni per dire a Typescript come\ncomportarsi. Per il momento non è importante il suo contenuto, ma lo andremo ad\nesplorare in futuro.\n\nLa seconda, è che i file che andremo ad implementare hanno estenzione `.ts` o `.tsx`.\nCome ad esempio, rispettivamente, i file `pages/api/hello.ts` e `pages/index.tsx`.\n\nI file `.ts` i file nativi _typescript_, mentre quelli `.tsx` contengono codice TypeScript\nscritti in JSX (ricordate? TypeScript + JSX = TSX). All'interno di questi file, infatti, troverete\nun misto tra TypeScript e HTML.\n\n#### Pagine ed API\n\nL'ultima cosa su cui voglio soffermarmi, prima di andare ad implementare finalmente del codice, è\nla cartella `pages` che trovate nel progetto.\n\nCome abbiamo detto NextJS è un framework (o metaframework dato che è basato su ReactJS), quindi non solo\noffre una serie di funzionalità ma impone allo sviluppatore un modo di organizzare il codice.\n\nLa cartella `pages` è una cartella importante in NextJS, in quanto qualsiasi cosa metteremo qui dientro (a parte alcune eccezioni che vedremo)\ndiventa automaticamente una pagina HTML del nostro progetto. Il file `pages/index.tsx` sarà tramutato nel file `index.html` del nostro sito,\ncioè la pagina inziale che sarà raggiunta tramite `https://<dominio>.<com>/`. Se volessimo fare una pagina chiamata `/about`, ci basterà\ncreare un file `pages/about.tsx`. Anche il contenuto di questi file deve essere implementato in un certo modo. In particolare, come vedremo nella sezione\nsuccessiva, il componente React che implementa la pagina deve essere esportato con `export default`.\n\nIl file `pages/_app.tsx` è una delle eccezioni che dicevo prima, in questo file troviamo il componente `App` che _wrappa_ tutte le nostre pagine. Anche\nin questo caso, per ora non dobbiamo preoccuparci troppo del funzionamento perchè lo esploreremo per bene in seguito. Giusto per completezza, NextJS\nprevede altri due file che non verranno gestiti come pagine, che sono `_document.tsx` e `_middleware.ts`. Scopriremo il comportamento di questi file in futuro.\n\nInfine, degno di nota è la cartella `pages/api`. Tutto i file contenuti in questa cartella non verranno gestiti come pagine, ma come _api endopoint_. Questi\nfile saranno sempre eseguiti dal backend (quindi non sono pagine frontend o generate staticamente) ed il loro risultato non sarò necessariamente\nuna pagina HTML ma dei dati (solitamente ritornati in formato JSON). Un esempio classico dell'utilizzo di queste API è quello di permettere agli utenti\ndi effettuare un'autenticazione e ricevere dati personalizzati. Ma anche in questo caso avremmo tempo per approfondire andando avanti in questo progetto.\n\n### Customizziamo la nostra pagina\n\nDopo la parte introduttiva, siamo finalmente pronti per esplorare il codice e iniziare a modificarlo. Iniziamo\nquindi a vedere come customizzare il nostro sito.\n\nAbbiamo visto che la pagina principale del sito è gestita nel file `pages/index.tsx`. Vediamo cosa ci sta dentro:\n\nDalla sezione di import\n\n```tsx\nimport type { NextPage } from \"next\";\nimport Head from \"next/head\";\nimport Image from \"next/image\";\nimport styles from \"../styles/Home.module.css\";\n```\n\nvediamo che il progetto importa due componenti da NextJS (li approfondiremo in seguito), un file di stili CSS\n(cosa che a me non piace molto e in futuro eviteremo di importare il CSS in questo modo). Vediamo infine subito una\nsintessi nuova che non abbiamo approfondito: `import type`.\n\nQuesta è una sintassi specifica di TypeScript (quindi non di JavaScript) che ci permette di importare un oggetto solo\nper utilizzarne la definizione dei tipi. In realtà ogni riga `import type` viene semplicemente cancellata in JavaScript,\nè serve al progetto TypeScript per identificare una definizione tramite type annotation.\n\nVediamo subito, infatti, che l'oggetto `NextPage` viene usato per definire una pagina NextJS, come mostrato qui:\n\n```tsx\nconst Home: NextPage = () => {\n  /// ....\n};\n\nexport default Home;\n```\n\nL'oggeto Home è la nostra pagina NextJS, e ce ne accorgiamo perchè viene esportato con `export default` alla fine del documento.\nVi ricordo, infatti, che in NextJS l'oggetto che viene esportato di default all'interno di un file dentro la cartella `pages` è quello\nche poi viene renderizzato come pagina.\n\n`Home` è un componente funzionale React, cioè il modo consgliato in react per definire un componente da renderizzare. In particolare\nun componente funzionale è una funzione il cui valore di ritorno è un oggetto JSX.\n\nVedimao infatti che quello che torna questa funzione è un `<div>` html con dentro alcune cose.\n\nSe proviamo a modificare l'html di questo componente, vedremo immediatamente una modificare nella pagina renderizzata.\n\nAd esempio, fare questo cambiamento:\n\n```diff\n<h1 className={styles.title}>\n  - Welcome to <a href=\"https://nextjs.org\">Next.js!</a>\n  + Questo è il mio primo progetto\n</h1>\n```\n\nLanciando il progetto con `npm run dev` vedremo a nel browser\nla nuova pagina modificata.\n\n![First Site 2](./first-site2.png)\n",
          "slug": "primi-passi-con-nextjs",
          "frontMatter": {
            "title": "Primi passi con NextJS",
            "readTime": 14,
            "imagePath": "/courses/nextjs-megatutorial/00002-primi-passi-nextjs",
            "description": "Iniziamo a usare React e NextJS creando un semplice progetto",
            "published": true
          }
        },
        {
          "file": "/Users/ludusrusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/00003-react-components/index.mdx",
          "content": "",
          "slug": "primi-passi-con-nextjs",
          "frontMatter": {
            "title": "React Components",
            "readTime": 1,
            "imagePath": "/courses/nextjs-megatutorial/00003-react-components",
            "description": "Iniziamo a usare React e NextJS creando un semplice progetto",
            "published": false
          }
        },
        {
          "file": "/Users/ludusrusso/develop/github.com/ludusrusso/www.ludusrusso.dev/content/courses/nextjs-megatutorial/00004-react-components copy/index.mdx",
          "content": "",
          "slug": "primi-passi-con-nextjs",
          "frontMatter": {
            "title": "Costriamo la prima pagina del nostro blog",
            "readTime": 1,
            "imagePath": "/courses/nextjs-megatutorial/00004-react-components copy",
            "description": "Iniziamo a usare React e NextJS creando un semplice progetto",
            "published": false
          }
        }
      ],
      "author": "ludusrusso",
      "title": "NextJS Mega Tutorial",
      "readTime": 3,
      "href": "/courses/nextjs-mega-tutorial",
      "imagePath": "/courses/nextjs-megatutorial",
      "description": "NextJS e React sono dei tool molto usati nel mondo dello sviluppo web moderno. Chiunque voglia diventare uno sviluppatore web può puntare su questi progetti per iniziare ad imparare e sviluppare i propri progetti."
    }
  }
]